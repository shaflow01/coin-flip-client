{
  "version": 3,
  "sources": ["../../@noble/curves/src/abstract/modular.ts", "../../@noble/curves/src/abstract/hash-to-curve.ts", "../../@noble/curves/src/abstract/curve.ts", "../../@noble/curves/src/abstract/weierstrass.ts", "../../@noble/curves/src/abstract/bls.ts", "../../@noble/curves/src/bls12-381.ts"],
  "sourcesContent": ["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Utilities for modular arithmetics and finite fields\r\nimport {\r\n  bitMask,\r\n  numberToBytesBE,\r\n  numberToBytesLE,\r\n  bytesToNumberBE,\r\n  bytesToNumberLE,\r\n  ensureBytes,\r\n  validateObject,\r\n} from './utils.js';\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\r\n// prettier-ignore\r\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\r\n// prettier-ignore\r\nconst _9n = BigInt(9), _16n = BigInt(16);\r\n\r\n// Calculates a modulo b\r\nexport function mod(a: bigint, b: bigint): bigint {\r\n  const result = a % b;\r\n  return result >= _0n ? result : b + result;\r\n}\r\n/**\r\n * Efficiently raise num to power and do modular division.\r\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\r\n * @example\r\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\r\n */\r\n// TODO: use field version && remove\r\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\r\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\r\n  if (modulo === _1n) return _0n;\r\n  let res = _1n;\r\n  while (power > _0n) {\r\n    if (power & _1n) res = (res * num) % modulo;\r\n    num = (num * num) % modulo;\r\n    power >>= _1n;\r\n  }\r\n  return res;\r\n}\r\n\r\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\r\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\r\n  let res = x;\r\n  while (power-- > _0n) {\r\n    res *= res;\r\n    res %= modulo;\r\n  }\r\n  return res;\r\n}\r\n\r\n// Inverses number over modulo\r\nexport function invert(number: bigint, modulo: bigint): bigint {\r\n  if (number === _0n || modulo <= _0n) {\r\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\r\n  }\r\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\r\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\r\n  let a = mod(number, modulo);\r\n  let b = modulo;\r\n  // prettier-ignore\r\n  let x = _0n, y = _1n, u = _1n, v = _0n;\r\n  while (a !== _0n) {\r\n    // JIT applies optimization if those two lines follow each other\r\n    const q = b / a;\r\n    const r = b % a;\r\n    const m = x - u * q;\r\n    const n = y - v * q;\r\n    // prettier-ignore\r\n    b = a, a = r, x = u, y = v, u = m, v = n;\r\n  }\r\n  const gcd = b;\r\n  if (gcd !== _1n) throw new Error('invert: does not exist');\r\n  return mod(x, modulo);\r\n}\r\n\r\n/**\r\n * Tonelli-Shanks square root search algorithm.\r\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\r\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\r\n * Will start an infinite loop if field order P is not prime.\r\n * @param P field order\r\n * @returns function that takes field Fp (created from P) and number n\r\n */\r\nexport function tonelliShanks(P: bigint) {\r\n  // Legendre constant: used to calculate Legendre symbol (a | p),\r\n  // which denotes the value of a^((p-1)/2) (mod p).\r\n  // (a | p) ‚â° 1    if a is a square (mod p)\r\n  // (a | p) ‚â° -1   if a is not a square (mod p)\r\n  // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\r\n  const legendreC = (P - _1n) / _2n;\r\n\r\n  let Q: bigint, S: number, Z: bigint;\r\n  // Step 1: By factoring out powers of 2 from p - 1,\r\n  // find q and s such that p - 1 = q*(2^s) with q odd\r\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\r\n\r\n  // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\r\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\r\n\r\n  // Fast-path\r\n  if (S === 1) {\r\n    const p1div4 = (P + _1n) / _4n;\r\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\r\n      const root = Fp.pow(n, p1div4);\r\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\r\n      return root;\r\n    };\r\n  }\r\n\r\n  // Slow-path\r\n  const Q1div2 = (Q + _1n) / _2n;\r\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\r\n    // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\r\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\r\n    let r = S;\r\n    // TODO: will fail at Fp2/etc\r\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\r\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\r\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\r\n\r\n    while (!Fp.eql(b, Fp.ONE)) {\r\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\r\n      // Find m such b^(2^m)==1\r\n      let m = 1;\r\n      for (let t2 = Fp.sqr(b); m < r; m++) {\r\n        if (Fp.eql(t2, Fp.ONE)) break;\r\n        t2 = Fp.sqr(t2); // t2 *= t2\r\n      }\r\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\r\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\r\n      g = Fp.sqr(ge); // g = ge * ge\r\n      x = Fp.mul(x, ge); // x *= ge\r\n      b = Fp.mul(b, g); // b *= g\r\n      r = m;\r\n    }\r\n    return x;\r\n  };\r\n}\r\n\r\nexport function FpSqrt(P: bigint) {\r\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\r\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\r\n\r\n  // P ‚â° 3 (mod 4)\r\n  // ‚àön = n^((P+1)/4)\r\n  if (P % _4n === _3n) {\r\n    // Not all roots possible!\r\n    // const ORDER =\r\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\r\n    // const NUM = 72057594037927816n;\r\n    const p1div4 = (P + _1n) / _4n;\r\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\r\n      const root = Fp.pow(n, p1div4);\r\n      // Throw if root**2 != n\r\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\r\n      return root;\r\n    };\r\n  }\r\n\r\n  // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\r\n  if (P % _8n === _5n) {\r\n    const c1 = (P - _5n) / _8n;\r\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\r\n      const n2 = Fp.mul(n, _2n);\r\n      const v = Fp.pow(n2, c1);\r\n      const nv = Fp.mul(n, v);\r\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\r\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\r\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\r\n      return root;\r\n    };\r\n  }\r\n\r\n  // P ‚â° 9 (mod 16)\r\n  if (P % _16n === _9n) {\r\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\r\n    // Means we cannot use sqrt for constants at all!\r\n    //\r\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\r\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\r\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\r\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\r\n    // sqrt = (x) => {\r\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\r\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\r\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\r\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\r\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\r\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\r\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\r\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\r\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\r\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\r\n    // }\r\n  }\r\n\r\n  // Other cases: Tonelli-Shanks algorithm\r\n  return tonelliShanks(P);\r\n}\r\n\r\n// Little-endian check for first LE bit (last BE bit);\r\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\r\n\r\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\r\nexport interface IField<T> {\r\n  ORDER: bigint;\r\n  BYTES: number;\r\n  BITS: number;\r\n  MASK: bigint;\r\n  ZERO: T;\r\n  ONE: T;\r\n  // 1-arg\r\n  create: (num: T) => T;\r\n  isValid: (num: T) => boolean;\r\n  is0: (num: T) => boolean;\r\n  neg(num: T): T;\r\n  inv(num: T): T;\r\n  sqrt(num: T): T;\r\n  sqr(num: T): T;\r\n  // 2-args\r\n  eql(lhs: T, rhs: T): boolean;\r\n  add(lhs: T, rhs: T): T;\r\n  sub(lhs: T, rhs: T): T;\r\n  mul(lhs: T, rhs: T | bigint): T;\r\n  pow(lhs: T, power: bigint): T;\r\n  div(lhs: T, rhs: T | bigint): T;\r\n  // N for NonNormalized (for now)\r\n  addN(lhs: T, rhs: T): T;\r\n  subN(lhs: T, rhs: T): T;\r\n  mulN(lhs: T, rhs: T | bigint): T;\r\n  sqrN(num: T): T;\r\n\r\n  // Optional\r\n  // Should be same as sgn0 function in\r\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\r\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\r\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\r\n  // legendre?(num: T): T;\r\n  pow(lhs: T, power: bigint): T;\r\n  invertBatch: (lst: T[]) => T[];\r\n  toBytes(num: T): Uint8Array;\r\n  fromBytes(bytes: Uint8Array): T;\r\n  // If c is False, CMOV returns a, otherwise it returns b.\r\n  cmov(a: T, b: T, c: boolean): T;\r\n}\r\n// prettier-ignore\r\nconst FIELD_FIELDS = [\r\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\r\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\r\n  'addN', 'subN', 'mulN', 'sqrN'\r\n] as const;\r\nexport function validateField<T>(field: IField<T>) {\r\n  const initial = {\r\n    ORDER: 'bigint',\r\n    MASK: 'bigint',\r\n    BYTES: 'isSafeInteger',\r\n    BITS: 'isSafeInteger',\r\n  } as Record<string, string>;\r\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\r\n    map[val] = 'function';\r\n    return map;\r\n  }, initial);\r\n  return validateObject(field, opts);\r\n}\r\n\r\n// Generic field functions\r\n\r\n/**\r\n * Same as `pow` but for Fp: non-constant-time.\r\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\r\n */\r\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\r\n  // Should have same speed as pow for bigints\r\n  // TODO: benchmark!\r\n  if (power < _0n) throw new Error('Expected power > 0');\r\n  if (power === _0n) return f.ONE;\r\n  if (power === _1n) return num;\r\n  let p = f.ONE;\r\n  let d = num;\r\n  while (power > _0n) {\r\n    if (power & _1n) p = f.mul(p, d);\r\n    d = f.sqr(d);\r\n    power >>= _1n;\r\n  }\r\n  return p;\r\n}\r\n\r\n/**\r\n * Efficiently invert an array of Field elements.\r\n * `inv(0)` will return `undefined` here: make sure to throw an error.\r\n */\r\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\r\n  const tmp = new Array(nums.length);\r\n  // Walk from first to last, multiply them by each other MOD p\r\n  const lastMultiplied = nums.reduce((acc, num, i) => {\r\n    if (f.is0(num)) return acc;\r\n    tmp[i] = acc;\r\n    return f.mul(acc, num);\r\n  }, f.ONE);\r\n  // Invert last element\r\n  const inverted = f.inv(lastMultiplied);\r\n  // Walk from last to first, multiply them by inverted each other MOD p\r\n  nums.reduceRight((acc, num, i) => {\r\n    if (f.is0(num)) return acc;\r\n    tmp[i] = f.mul(acc, tmp[i]);\r\n    return f.mul(acc, num);\r\n  }, inverted);\r\n  return tmp;\r\n}\r\n\r\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\r\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\r\n}\r\n\r\n// This function returns True whenever the value x is a square in the field F.\r\nexport function FpIsSquare<T>(f: IField<T>) {\r\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\r\n  return (x: T): boolean => {\r\n    const p = f.pow(x, legendreConst);\r\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\r\n  };\r\n}\r\n\r\n// CURVE.n lengths\r\nexport function nLength(n: bigint, nBitLength?: number) {\r\n  // Bit size, byte size of CURVE.n\r\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\r\n  const nByteLength = Math.ceil(_nBitLength / 8);\r\n  return { nBitLength: _nBitLength, nByteLength };\r\n}\r\n\r\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\r\n/**\r\n * Initializes a finite field over prime. **Non-primes are not supported.**\r\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\r\n * Major performance optimizations:\r\n * * a) denormalized operations like mulN instead of mul\r\n * * b) same object shape: never add or remove keys\r\n * * c) Object.freeze\r\n * @param ORDER prime positive bigint\r\n * @param bitLen how many bits the field consumes\r\n * @param isLE (def: false) if encoding / decoding should be in little-endian\r\n * @param redef optional faster redefinitions of sqrt and other methods\r\n */\r\nexport function Field(\r\n  ORDER: bigint,\r\n  bitLen?: number,\r\n  isLE = false,\r\n  redef: Partial<IField<bigint>> = {}\r\n): Readonly<FpField> {\r\n  if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\r\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\r\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\r\n  const sqrtP = FpSqrt(ORDER);\r\n  const f: Readonly<FpField> = Object.freeze({\r\n    ORDER,\r\n    BITS,\r\n    BYTES,\r\n    MASK: bitMask(BITS),\r\n    ZERO: _0n,\r\n    ONE: _1n,\r\n    create: (num) => mod(num, ORDER),\r\n    isValid: (num) => {\r\n      if (typeof num !== 'bigint')\r\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\r\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\r\n    },\r\n    is0: (num) => num === _0n,\r\n    isOdd: (num) => (num & _1n) === _1n,\r\n    neg: (num) => mod(-num, ORDER),\r\n    eql: (lhs, rhs) => lhs === rhs,\r\n\r\n    sqr: (num) => mod(num * num, ORDER),\r\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\r\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\r\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\r\n    pow: (num, power) => FpPow(f, num, power),\r\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\r\n\r\n    // Same as above, but doesn't normalize\r\n    sqrN: (num) => num * num,\r\n    addN: (lhs, rhs) => lhs + rhs,\r\n    subN: (lhs, rhs) => lhs - rhs,\r\n    mulN: (lhs, rhs) => lhs * rhs,\r\n\r\n    inv: (num) => invert(num, ORDER),\r\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\r\n    invertBatch: (lst) => FpInvertBatch(f, lst),\r\n    // TODO: do we really need constant cmov?\r\n    // We don't have const-time bigints anyway, so probably will be not very useful\r\n    cmov: (a, b, c) => (c ? b : a),\r\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\r\n    fromBytes: (bytes) => {\r\n      if (bytes.length !== BYTES)\r\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\r\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\r\n    },\r\n  } as FpField);\r\n  return Object.freeze(f);\r\n}\r\n\r\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\r\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\r\n  const root = Fp.sqrt(elm);\r\n  return Fp.isOdd(root) ? root : Fp.neg(root);\r\n}\r\n\r\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\r\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\r\n  const root = Fp.sqrt(elm);\r\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\r\n}\r\n\r\n/**\r\n * \"Constant-time\" private key generation utility.\r\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\r\n * Which makes it slightly more biased, less secure.\r\n * @deprecated use mapKeyToField instead\r\n */\r\nexport function hashToPrivateScalar(\r\n  hash: string | Uint8Array,\r\n  groupOrder: bigint,\r\n  isLE = false\r\n): bigint {\r\n  hash = ensureBytes('privateHash', hash);\r\n  const hashLen = hash.length;\r\n  const minLen = nLength(groupOrder).nByteLength + 8;\r\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\r\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\r\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\r\n  return mod(num, groupOrder - _1n) + _1n;\r\n}\r\n\r\n/**\r\n * Returns total number of bytes consumed by the field element.\r\n * For example, 32 bytes for usual 256-bit weierstrass curve.\r\n * @param fieldOrder number of field elements, usually CURVE.n\r\n * @returns byte length of field\r\n */\r\nexport function getFieldBytesLength(fieldOrder: bigint): number {\r\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\r\n  const bitLength = fieldOrder.toString(2).length;\r\n  return Math.ceil(bitLength / 8);\r\n}\r\n\r\n/**\r\n * Returns minimal amount of bytes that can be safely reduced\r\n * by field order.\r\n * Should be 2^-128 for 128-bit curve such as P256.\r\n * @param fieldOrder number of field elements, usually CURVE.n\r\n * @returns byte length of target hash\r\n */\r\nexport function getMinHashLength(fieldOrder: bigint): number {\r\n  const length = getFieldBytesLength(fieldOrder);\r\n  return length + Math.ceil(length / 2);\r\n}\r\n\r\n/**\r\n * \"Constant-time\" private key generation utility.\r\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\r\n * and convert them into private scalar, with the modulo bias being negligible.\r\n * Needs at least 48 bytes of input for 32-byte private key.\r\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\r\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\r\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\r\n * @param hash hash output from SHA3 or a similar function\r\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\r\n * @param isLE interpret hash bytes as LE num\r\n * @returns valid private scalar\r\n */\r\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\r\n  const len = key.length;\r\n  const fieldLen = getFieldBytesLength(fieldOrder);\r\n  const minLen = getMinHashLength(fieldOrder);\r\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\r\n  if (len < 16 || len < minLen || len > 1024)\r\n    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\r\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\r\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\r\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\r\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\r\n}\r\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\nimport type { Group, GroupConstructor, AffinePoint } from './curve.js';\r\nimport { mod, IField } from './modular.js';\r\nimport type { CHash } from './utils.js';\r\nimport { bytesToNumberBE, isBytes, concatBytes, utf8ToBytes, validateObject } from './utils.js';\r\n\r\n/**\r\n * * `DST` is a domain separation tag, defined in section 2.2.5\r\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\r\n * * `m` is extension degree (1 for prime fields)\r\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\r\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\r\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\r\n */\r\ntype UnicodeOrBytes = string | Uint8Array;\r\nexport type Opts = {\r\n  DST: UnicodeOrBytes;\r\n  p: bigint;\r\n  m: number;\r\n  k: number;\r\n  expand: 'xmd' | 'xof';\r\n  hash: CHash;\r\n};\r\n\r\nfunction validateDST(dst: UnicodeOrBytes): Uint8Array {\r\n  if (isBytes(dst)) return dst;\r\n  if (typeof dst === 'string') return utf8ToBytes(dst);\r\n  throw new Error('DST must be Uint8Array or string');\r\n}\r\n\r\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\r\nconst os2ip = bytesToNumberBE;\r\n\r\n// Integer to Octet Stream (numberToBytesBE)\r\nfunction i2osp(value: number, length: number): Uint8Array {\r\n  if (value < 0 || value >= 1 << (8 * length)) {\r\n    throw new Error(`bad I2OSP call: value=${value} length=${length}`);\r\n  }\r\n  const res = Array.from({ length }).fill(0) as number[];\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    res[i] = value & 0xff;\r\n    value >>>= 8;\r\n  }\r\n  return new Uint8Array(res);\r\n}\r\n\r\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\r\n  const arr = new Uint8Array(a.length);\r\n  for (let i = 0; i < a.length; i++) {\r\n    arr[i] = a[i] ^ b[i];\r\n  }\r\n  return arr;\r\n}\r\n\r\nfunction abytes(item: unknown): void {\r\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\r\n}\r\nfunction isNum(item: unknown): void {\r\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\r\n}\r\n\r\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\r\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\r\nexport function expand_message_xmd(\r\n  msg: Uint8Array,\r\n  DST: Uint8Array,\r\n  lenInBytes: number,\r\n  H: CHash\r\n): Uint8Array {\r\n  abytes(msg);\r\n  abytes(DST);\r\n  isNum(lenInBytes);\r\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\r\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\r\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\r\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\r\n  if (ell > 255) throw new Error('Invalid xmd length');\r\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\r\n  const Z_pad = i2osp(0, r_in_bytes);\r\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\r\n  const b = new Array<Uint8Array>(ell);\r\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\r\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\r\n  for (let i = 1; i <= ell; i++) {\r\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\r\n    b[i] = H(concatBytes(...args));\r\n  }\r\n  const pseudo_random_bytes = concatBytes(...b);\r\n  return pseudo_random_bytes.slice(0, lenInBytes);\r\n}\r\n\r\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\r\n// 1. The collision resistance of H MUST be at least k bits.\r\n// 2. H MUST be an XOF that has been proved indifferentiable from\r\n//    a random oracle under a reasonable cryptographic assumption.\r\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\r\nexport function expand_message_xof(\r\n  msg: Uint8Array,\r\n  DST: Uint8Array,\r\n  lenInBytes: number,\r\n  k: number,\r\n  H: CHash\r\n): Uint8Array {\r\n  abytes(msg);\r\n  abytes(DST);\r\n  isNum(lenInBytes);\r\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\r\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\r\n  if (DST.length > 255) {\r\n    const dkLen = Math.ceil((2 * k) / 8);\r\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\r\n  }\r\n  if (lenInBytes > 65535 || DST.length > 255)\r\n    throw new Error('expand_message_xof: invalid lenInBytes');\r\n  return (\r\n    H.create({ dkLen: lenInBytes })\r\n      .update(msg)\r\n      .update(i2osp(lenInBytes, 2))\r\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\r\n      .update(DST)\r\n      .update(i2osp(DST.length, 1))\r\n      .digest()\r\n  );\r\n}\r\n\r\n/**\r\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\r\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\r\n * @param msg a byte string containing the message to hash\r\n * @param count the number of elements of F to output\r\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\r\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\r\n */\r\nexport function hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][] {\r\n  validateObject(options, {\r\n    DST: 'stringOrUint8Array',\r\n    p: 'bigint',\r\n    m: 'isSafeInteger',\r\n    k: 'isSafeInteger',\r\n    hash: 'hash',\r\n  });\r\n  const { p, k, m, hash, expand, DST: _DST } = options;\r\n  abytes(msg);\r\n  isNum(count);\r\n  const DST = validateDST(_DST);\r\n  const log2p = p.toString(2).length;\r\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\r\n  const len_in_bytes = count * m * L;\r\n  let prb; // pseudo_random_bytes\r\n  if (expand === 'xmd') {\r\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\r\n  } else if (expand === 'xof') {\r\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\r\n  } else if (expand === '_internal_pass') {\r\n    // for internal tests only\r\n    prb = msg;\r\n  } else {\r\n    throw new Error('expand must be \"xmd\" or \"xof\"');\r\n  }\r\n  const u = new Array(count);\r\n  for (let i = 0; i < count; i++) {\r\n    const e = new Array(m);\r\n    for (let j = 0; j < m; j++) {\r\n      const elm_offset = L * (j + i * m);\r\n      const tv = prb.subarray(elm_offset, elm_offset + L);\r\n      e[j] = mod(os2ip(tv), p);\r\n    }\r\n    u[i] = e;\r\n  }\r\n  return u;\r\n}\r\n\r\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: [T[], T[], T[], T[]]) {\r\n  // Make same order as in spec\r\n  const COEFF = map.map((i) => Array.from(i).reverse());\r\n  return (x: T, y: T) => {\r\n    const [xNum, xDen, yNum, yDen] = COEFF.map((val) =>\r\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\r\n    );\r\n    x = field.div(xNum, xDen); // xNum / xDen\r\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\r\n    return { x, y };\r\n  };\r\n}\r\n\r\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\r\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\r\n  toAffine(iz?: bigint): AffinePoint<T>;\r\n  clearCofactor(): H2CPoint<T>;\r\n  assertValidity(): void;\r\n}\r\n\r\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\r\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\r\n}\r\n\r\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\r\n\r\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\r\n// (changing DST is ok!)\r\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\r\n\r\nexport function createHasher<T>(\r\n  Point: H2CPointConstructor<T>,\r\n  mapToCurve: MapToCurve<T>,\r\n  def: Opts & { encodeDST?: UnicodeOrBytes }\r\n) {\r\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\r\n  return {\r\n    // Encodes byte string to elliptic curve.\r\n    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\r\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts) {\r\n      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options } as Opts);\r\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\r\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\r\n      const P = u0.add(u1).clearCofactor();\r\n      P.assertValidity();\r\n      return P;\r\n    },\r\n\r\n    // Encodes byte string to elliptic curve.\r\n    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\r\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts) {\r\n      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options } as Opts);\r\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\r\n      P.assertValidity();\r\n      return P;\r\n    },\r\n  };\r\n}\r\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Abelian group utilities\r\nimport { IField, validateField, nLength } from './modular.js';\r\nimport { validateObject } from './utils.js';\r\nconst _0n = BigInt(0);\r\nconst _1n = BigInt(1);\r\n\r\nexport type AffinePoint<T> = {\r\n  x: T;\r\n  y: T;\r\n} & { z?: never; t?: never };\r\n\r\nexport interface Group<T extends Group<T>> {\r\n  double(): T;\r\n  negate(): T;\r\n  add(other: T): T;\r\n  subtract(other: T): T;\r\n  equals(other: T): boolean;\r\n  multiply(scalar: bigint): T;\r\n}\r\n\r\nexport type GroupConstructor<T> = {\r\n  BASE: T;\r\n  ZERO: T;\r\n};\r\nexport type Mapper<T> = (i: T[]) => T[];\r\n\r\n// Elliptic curve multiplication of Point by scalar. Fragile.\r\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\r\n// Creates precomputation tables for fast multiplication:\r\n// - private scalar is split by fixed size windows of W bits\r\n// - every window point is collected from window's table & added to accumulator\r\n// - since windows are different, same point inside tables won't be accessed more than once per calc\r\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\r\n// - +1 window is neccessary for wNAF\r\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\r\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\r\n// windows to be in different memory locations\r\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\r\n  const constTimeNegate = (condition: boolean, item: T): T => {\r\n    const neg = item.negate();\r\n    return condition ? neg : item;\r\n  };\r\n  const opts = (W: number) => {\r\n    const windows = Math.ceil(bits / W) + 1; // +1, because\r\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\r\n    return { windows, windowSize };\r\n  };\r\n  return {\r\n    constTimeNegate,\r\n    // non-const time multiplication ladder\r\n    unsafeLadder(elm: T, n: bigint) {\r\n      let p = c.ZERO;\r\n      let d: T = elm;\r\n      while (n > _0n) {\r\n        if (n & _1n) p = p.add(d);\r\n        d = d.double();\r\n        n >>= _1n;\r\n      }\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * Creates a wNAF precomputation window. Used for caching.\r\n     * Default window size is set by `utils.precompute()` and is equal to 8.\r\n     * Number of precomputed points depends on the curve size:\r\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\r\n     * - ùëä is the window size\r\n     * - ùëõ is the bitlength of the curve order.\r\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\r\n     * @returns precomputed point tables flattened to a single array\r\n     */\r\n    precomputeWindow(elm: T, W: number): Group<T>[] {\r\n      const { windows, windowSize } = opts(W);\r\n      const points: T[] = [];\r\n      let p: T = elm;\r\n      let base = p;\r\n      for (let window = 0; window < windows; window++) {\r\n        base = p;\r\n        points.push(base);\r\n        // =1, because we skip zero\r\n        for (let i = 1; i < windowSize; i++) {\r\n          base = base.add(p);\r\n          points.push(base);\r\n        }\r\n        p = base.double();\r\n      }\r\n      return points;\r\n    },\r\n\r\n    /**\r\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\r\n     * @param W window size\r\n     * @param precomputes precomputed tables\r\n     * @param n scalar (we don't check here, but should be less than curve order)\r\n     * @returns real and fake (for const-time) points\r\n     */\r\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\r\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\r\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\r\n      const { windows, windowSize } = opts(W);\r\n\r\n      let p = c.ZERO;\r\n      let f = c.BASE;\r\n\r\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\r\n      const maxNumber = 2 ** W;\r\n      const shiftBy = BigInt(W);\r\n\r\n      for (let window = 0; window < windows; window++) {\r\n        const offset = window * windowSize;\r\n        // Extract W bits.\r\n        let wbits = Number(n & mask);\r\n\r\n        // Shift number by W bits.\r\n        n >>= shiftBy;\r\n\r\n        // If the bits are bigger than max size, we'll split those.\r\n        // +224 => 256 - 32\r\n        if (wbits > windowSize) {\r\n          wbits -= maxNumber;\r\n          n += _1n;\r\n        }\r\n\r\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\r\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\r\n        // there is negate now: it is possible that negated element from low value\r\n        // would be the same as high element, which will create carry into next window.\r\n        // It's not obvious how this can fail, but still worth investigating later.\r\n\r\n        // Check if we're onto Zero point.\r\n        // Add random point inside current window to f.\r\n        const offset1 = offset;\r\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\r\n        const cond1 = window % 2 !== 0;\r\n        const cond2 = wbits < 0;\r\n        if (wbits === 0) {\r\n          // The most important part for const-time getPublicKey\r\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\r\n        } else {\r\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\r\n        }\r\n      }\r\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\r\n      // Even if the variable is still unused, there are some checks which will\r\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\r\n      // At this point there is a way to F be infinity-point even if p is not,\r\n      // which makes it less const-time: around 1 bigint multiply.\r\n      return { p, f };\r\n    },\r\n\r\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\r\n      // @ts-ignore\r\n      const W: number = P._WINDOW_SIZE || 1;\r\n      // Calculate precomputes on a first run, reuse them after\r\n      let comp = precomputesMap.get(P);\r\n      if (!comp) {\r\n        comp = this.precomputeWindow(P, W) as T[];\r\n        if (W !== 1) {\r\n          precomputesMap.set(P, transform(comp));\r\n        }\r\n      }\r\n      return this.wNAF(W, comp, n);\r\n    },\r\n  };\r\n}\r\n\r\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\r\n// Though generator can be different (Fp2 / Fp6 for BLS).\r\nexport type BasicCurve<T> = {\r\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\r\n  n: bigint; // Curve order, total count of valid points in the field\r\n  nBitLength?: number; // bit length of curve order\r\n  nByteLength?: number; // byte length of curve order\r\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\r\n  hEff?: bigint; // Number to multiply to clear cofactor\r\n  Gx: T; // base point X coordinate\r\n  Gy: T; // base point Y coordinate\r\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\r\n};\r\n\r\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\r\n  validateField(curve.Fp);\r\n  validateObject(\r\n    curve,\r\n    {\r\n      n: 'bigint',\r\n      h: 'bigint',\r\n      Gx: 'field',\r\n      Gy: 'field',\r\n    },\r\n    {\r\n      nBitLength: 'isSafeInteger',\r\n      nByteLength: 'isSafeInteger',\r\n    }\r\n  );\r\n  // Set defaults\r\n  return Object.freeze({\r\n    ...nLength(curve.n, curve.nBitLength),\r\n    ...curve,\r\n    ...{ p: curve.Fp.ORDER },\r\n  } as const);\r\n}\r\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n// Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b\r\nimport * as mod from './modular.js';\r\nimport * as ut from './utils.js';\r\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\r\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\r\n\r\nexport type { AffinePoint };\r\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\r\ntype EndomorphismOpts = {\r\n  beta: bigint;\r\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\r\n};\r\nexport type BasicWCurve<T> = BasicCurve<T> & {\r\n  // Params: a, b\r\n  a: T;\r\n  b: T;\r\n\r\n  // Optional params\r\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\r\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\r\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\r\n  // When a cofactor != 1, there can be an effective methods to:\r\n  // 1. Determine whether a point is torsion-free\r\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\r\n  // 2. Clear torsion component\r\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\r\n};\r\n\r\ntype Entropy = Hex | true;\r\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\r\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\r\n\r\n/**\r\n * ### Design rationale for types\r\n *\r\n * * Interaction between classes from different curves should fail:\r\n *   `k256.Point.BASE.add(p256.Point.BASE)`\r\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\r\n * * Different calls of `curve()` would return different classes -\r\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\r\n *   it won't affect others\r\n *\r\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\r\n *\r\n * We can use generic types via some param, like curve opts, but that would:\r\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\r\n *     which is hard to debug.\r\n *     2. Params can be generic and we can't enforce them to be constant value:\r\n *     if somebody creates curve from non-constant params,\r\n *     it would be allowed to interact with other curves with non-constant params\r\n *\r\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\r\n */\r\n\r\n// Instance for 3d XYZ points\r\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\r\n  readonly px: T;\r\n  readonly py: T;\r\n  readonly pz: T;\r\n  get x(): T;\r\n  get y(): T;\r\n  multiply(scalar: bigint): ProjPointType<T>;\r\n  toAffine(iz?: T): AffinePoint<T>;\r\n  isTorsionFree(): boolean;\r\n  clearCofactor(): ProjPointType<T>;\r\n  assertValidity(): void;\r\n  hasEvenY(): boolean;\r\n  toRawBytes(isCompressed?: boolean): Uint8Array;\r\n  toHex(isCompressed?: boolean): string;\r\n\r\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\r\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\r\n  _setWindowSize(windowSize: number): void;\r\n}\r\n// Static methods for 3d XYZ points\r\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\r\n  new (x: T, y: T, z: T): ProjPointType<T>;\r\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\r\n  fromHex(hex: Hex): ProjPointType<T>;\r\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\r\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\r\n}\r\n\r\nexport type CurvePointsType<T> = BasicWCurve<T> & {\r\n  // Bytes\r\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\r\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\r\n};\r\n\r\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\r\n  const opts = validateBasic(curve);\r\n  ut.validateObject(\r\n    opts,\r\n    {\r\n      a: 'field',\r\n      b: 'field',\r\n    },\r\n    {\r\n      allowedPrivateKeyLengths: 'array',\r\n      wrapPrivateKey: 'boolean',\r\n      isTorsionFree: 'function',\r\n      clearCofactor: 'function',\r\n      allowInfinityPoint: 'boolean',\r\n      fromBytes: 'function',\r\n      toBytes: 'function',\r\n    }\r\n  );\r\n  const { endo, Fp, a } = opts;\r\n  if (endo) {\r\n    if (!Fp.eql(a, Fp.ZERO)) {\r\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\r\n    }\r\n    if (\r\n      typeof endo !== 'object' ||\r\n      typeof endo.beta !== 'bigint' ||\r\n      typeof endo.splitScalar !== 'function'\r\n    ) {\r\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\r\n    }\r\n  }\r\n  return Object.freeze({ ...opts } as const);\r\n}\r\n\r\nexport type CurvePointsRes<T> = {\r\n  CURVE: ReturnType<typeof validatePointOpts<T>>;\r\n  ProjectivePoint: ProjConstructor<T>;\r\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\r\n  weierstrassEquation: (x: T) => T;\r\n  isWithinCurveOrder: (num: bigint) => boolean;\r\n};\r\n\r\n// ASN.1 DER encoding utilities\r\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\r\nexport const DER = {\r\n  // asn.1 DER encoding utils\r\n  Err: class DERErr extends Error {\r\n    constructor(m = '') {\r\n      super(m);\r\n    }\r\n  },\r\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\r\n    const { Err: E } = DER;\r\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\r\n    const len = data[1];\r\n    const res = data.subarray(2, len + 2);\r\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\r\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\r\n    // since we always use positive integers here. It must always be empty:\r\n    // - add zero byte if exists\r\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\r\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\r\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\r\n      throw new E('Invalid signature integer: unnecessary leading zero');\r\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\r\n  },\r\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\r\n    // parse DER signature\r\n    const { Err: E } = DER;\r\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\r\n    if (!ut.isBytes(data)) throw new Error('ui8a expected');\r\n    let l = data.length;\r\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\r\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\r\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\r\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\r\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\r\n    return { r, s };\r\n  },\r\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\r\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\r\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\r\n    const h = (num: number | bigint) => {\r\n      const hex = num.toString(16);\r\n      return hex.length & 1 ? `0${hex}` : hex;\r\n    };\r\n    const s = slice(h(sig.s));\r\n    const r = slice(h(sig.r));\r\n    const shl = s.length / 2;\r\n    const rhl = r.length / 2;\r\n    const sl = h(shl);\r\n    const rl = h(rhl);\r\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\r\n  },\r\n};\r\n\r\n// Be friendly to bad ECMAScript parsers by not using bigint literals\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\r\n\r\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>): CurvePointsRes<T> {\r\n  const CURVE = validatePointOpts(opts);\r\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\r\n\r\n  const toBytes =\r\n    CURVE.toBytes ||\r\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\r\n      const a = point.toAffine();\r\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\r\n    });\r\n  const fromBytes =\r\n    CURVE.fromBytes ||\r\n    ((bytes: Uint8Array) => {\r\n      // const head = bytes[0];\r\n      const tail = bytes.subarray(1);\r\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\r\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\r\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\r\n      return { x, y };\r\n    });\r\n\r\n  /**\r\n   * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\r\n   * @returns y¬≤\r\n   */\r\n  function weierstrassEquation(x: T): T {\r\n    const { a, b } = CURVE;\r\n    const x2 = Fp.sqr(x); // x * x\r\n    const x3 = Fp.mul(x2, x); // x2 * x\r\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\r\n  }\r\n  // Validate whether the passed curve params are valid.\r\n  // We check if curve equation works for generator point.\r\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\r\n  // ProjectivePoint class has not been initialized yet.\r\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\r\n    throw new Error('bad generator point: equation left != right');\r\n\r\n  // Valid group elements reside in range 1..n-1\r\n  function isWithinCurveOrder(num: bigint): boolean {\r\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\r\n  }\r\n  function assertGE(num: bigint) {\r\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\r\n  }\r\n  // Validates if priv key is valid and converts it to bigint.\r\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\r\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\r\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\r\n    if (lengths && typeof key !== 'bigint') {\r\n      if (ut.isBytes(key)) key = ut.bytesToHex(key);\r\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\r\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\r\n      key = key.padStart(nByteLength * 2, '0');\r\n    }\r\n    let num: bigint;\r\n    try {\r\n      num =\r\n        typeof key === 'bigint'\r\n          ? key\r\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\r\n    } catch (error) {\r\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\r\n    }\r\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\r\n    assertGE(num); // num in range [1..N-1]\r\n    return num;\r\n  }\r\n\r\n  const pointPrecomputes = new Map<Point, Point[]>();\r\n  function assertPrjPoint(other: unknown) {\r\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\r\n  }\r\n  /**\r\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\r\n   * Default Point works in 2d / affine coordinates: (x, y)\r\n   * We're doing calculations in projective, because its operations don't require costly inversion.\r\n   */\r\n  class Point implements ProjPointType<T> {\r\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\r\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\r\n\r\n    constructor(\r\n      readonly px: T,\r\n      readonly py: T,\r\n      readonly pz: T\r\n    ) {\r\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\r\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\r\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\r\n    }\r\n\r\n    // Does not validate if the point is on-curve.\r\n    // Use fromHex instead, or call assertValidity() later.\r\n    static fromAffine(p: AffinePoint<T>): Point {\r\n      const { x, y } = p || {};\r\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\r\n      if (p instanceof Point) throw new Error('projective point not allowed');\r\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\r\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\r\n      if (is0(x) && is0(y)) return Point.ZERO;\r\n      return new Point(x, y, Fp.ONE);\r\n    }\r\n\r\n    get x(): T {\r\n      return this.toAffine().x;\r\n    }\r\n    get y(): T {\r\n      return this.toAffine().y;\r\n    }\r\n\r\n    /**\r\n     * Takes a bunch of Projective Points but executes only one\r\n     * inversion on all of them. Inversion is very slow operation,\r\n     * so this improves performance massively.\r\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\r\n     */\r\n    static normalizeZ(points: Point[]): Point[] {\r\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\r\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\r\n    }\r\n\r\n    /**\r\n     * Converts hash string or Uint8Array to Point.\r\n     * @param hex short/long ECDSA hex\r\n     */\r\n    static fromHex(hex: Hex): Point {\r\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\r\n      P.assertValidity();\r\n      return P;\r\n    }\r\n\r\n    // Multiplies generator point by privateKey.\r\n    static fromPrivateKey(privateKey: PrivKey) {\r\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\r\n    }\r\n\r\n    // We calculate precomputes for elliptic curve point multiplication\r\n    // using windowed method. This specifies window size and\r\n    // stores precomputed values. Usually only base point would be precomputed.\r\n    _WINDOW_SIZE?: number;\r\n\r\n    // \"Private method\", don't use it directly\r\n    _setWindowSize(windowSize: number) {\r\n      this._WINDOW_SIZE = windowSize;\r\n      pointPrecomputes.delete(this);\r\n    }\r\n\r\n    // A point on curve is valid if it conforms to equation.\r\n    assertValidity(): void {\r\n      if (this.is0()) {\r\n        // (0, 1, 0) aka ZERO is invalid in most contexts.\r\n        // In BLS, ZERO can be serialized, so we allow it.\r\n        // (0, 0, 0) is wrong representation of ZERO and is always invalid.\r\n        if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\r\n        throw new Error('bad point: ZERO');\r\n      }\r\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\r\n      const { x, y } = this.toAffine();\r\n      // Check if x, y are valid field elements\r\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\r\n      const left = Fp.sqr(y); // y¬≤\r\n      const right = weierstrassEquation(x); // x¬≥ + ax + b\r\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\r\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\r\n    }\r\n    hasEvenY(): boolean {\r\n      const { y } = this.toAffine();\r\n      if (Fp.isOdd) return !Fp.isOdd(y);\r\n      throw new Error(\"Field doesn't support isOdd\");\r\n    }\r\n\r\n    /**\r\n     * Compare one point to another.\r\n     */\r\n    equals(other: Point): boolean {\r\n      assertPrjPoint(other);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      const { px: X2, py: Y2, pz: Z2 } = other;\r\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\r\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\r\n      return U1 && U2;\r\n    }\r\n\r\n    /**\r\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\r\n     */\r\n    negate(): Point {\r\n      return new Point(this.px, Fp.neg(this.py), this.pz);\r\n    }\r\n\r\n    // Renes-Costello-Batina exception-free doubling formula.\r\n    // There is 30% faster Jacobian formula, but it is not complete.\r\n    // https://eprint.iacr.org/2015/1060, algorithm 3\r\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\r\n    double() {\r\n      const { a, b } = CURVE;\r\n      const b3 = Fp.mul(b, _3n);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n      let t0 = Fp.mul(X1, X1); // step 1\r\n      let t1 = Fp.mul(Y1, Y1);\r\n      let t2 = Fp.mul(Z1, Z1);\r\n      let t3 = Fp.mul(X1, Y1);\r\n      t3 = Fp.add(t3, t3); // step 5\r\n      Z3 = Fp.mul(X1, Z1);\r\n      Z3 = Fp.add(Z3, Z3);\r\n      X3 = Fp.mul(a, Z3);\r\n      Y3 = Fp.mul(b3, t2);\r\n      Y3 = Fp.add(X3, Y3); // step 10\r\n      X3 = Fp.sub(t1, Y3);\r\n      Y3 = Fp.add(t1, Y3);\r\n      Y3 = Fp.mul(X3, Y3);\r\n      X3 = Fp.mul(t3, X3);\r\n      Z3 = Fp.mul(b3, Z3); // step 15\r\n      t2 = Fp.mul(a, t2);\r\n      t3 = Fp.sub(t0, t2);\r\n      t3 = Fp.mul(a, t3);\r\n      t3 = Fp.add(t3, Z3);\r\n      Z3 = Fp.add(t0, t0); // step 20\r\n      t0 = Fp.add(Z3, t0);\r\n      t0 = Fp.add(t0, t2);\r\n      t0 = Fp.mul(t0, t3);\r\n      Y3 = Fp.add(Y3, t0);\r\n      t2 = Fp.mul(Y1, Z1); // step 25\r\n      t2 = Fp.add(t2, t2);\r\n      t0 = Fp.mul(t2, t3);\r\n      X3 = Fp.sub(X3, t0);\r\n      Z3 = Fp.mul(t2, t1);\r\n      Z3 = Fp.add(Z3, Z3); // step 30\r\n      Z3 = Fp.add(Z3, Z3);\r\n      return new Point(X3, Y3, Z3);\r\n    }\r\n\r\n    // Renes-Costello-Batina exception-free addition formula.\r\n    // There is 30% faster Jacobian formula, but it is not complete.\r\n    // https://eprint.iacr.org/2015/1060, algorithm 1\r\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\r\n    add(other: Point): Point {\r\n      assertPrjPoint(other);\r\n      const { px: X1, py: Y1, pz: Z1 } = this;\r\n      const { px: X2, py: Y2, pz: Z2 } = other;\r\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\r\n      const a = CURVE.a;\r\n      const b3 = Fp.mul(CURVE.b, _3n);\r\n      let t0 = Fp.mul(X1, X2); // step 1\r\n      let t1 = Fp.mul(Y1, Y2);\r\n      let t2 = Fp.mul(Z1, Z2);\r\n      let t3 = Fp.add(X1, Y1);\r\n      let t4 = Fp.add(X2, Y2); // step 5\r\n      t3 = Fp.mul(t3, t4);\r\n      t4 = Fp.add(t0, t1);\r\n      t3 = Fp.sub(t3, t4);\r\n      t4 = Fp.add(X1, Z1);\r\n      let t5 = Fp.add(X2, Z2); // step 10\r\n      t4 = Fp.mul(t4, t5);\r\n      t5 = Fp.add(t0, t2);\r\n      t4 = Fp.sub(t4, t5);\r\n      t5 = Fp.add(Y1, Z1);\r\n      X3 = Fp.add(Y2, Z2); // step 15\r\n      t5 = Fp.mul(t5, X3);\r\n      X3 = Fp.add(t1, t2);\r\n      t5 = Fp.sub(t5, X3);\r\n      Z3 = Fp.mul(a, t4);\r\n      X3 = Fp.mul(b3, t2); // step 20\r\n      Z3 = Fp.add(X3, Z3);\r\n      X3 = Fp.sub(t1, Z3);\r\n      Z3 = Fp.add(t1, Z3);\r\n      Y3 = Fp.mul(X3, Z3);\r\n      t1 = Fp.add(t0, t0); // step 25\r\n      t1 = Fp.add(t1, t0);\r\n      t2 = Fp.mul(a, t2);\r\n      t4 = Fp.mul(b3, t4);\r\n      t1 = Fp.add(t1, t2);\r\n      t2 = Fp.sub(t0, t2); // step 30\r\n      t2 = Fp.mul(a, t2);\r\n      t4 = Fp.add(t4, t2);\r\n      t0 = Fp.mul(t1, t4);\r\n      Y3 = Fp.add(Y3, t0);\r\n      t0 = Fp.mul(t5, t4); // step 35\r\n      X3 = Fp.mul(t3, X3);\r\n      X3 = Fp.sub(X3, t0);\r\n      t0 = Fp.mul(t3, t1);\r\n      Z3 = Fp.mul(t5, Z3);\r\n      Z3 = Fp.add(Z3, t0); // step 40\r\n      return new Point(X3, Y3, Z3);\r\n    }\r\n\r\n    subtract(other: Point) {\r\n      return this.add(other.negate());\r\n    }\r\n\r\n    private is0() {\r\n      return this.equals(Point.ZERO);\r\n    }\r\n    private wNAF(n: bigint): { p: Point; f: Point } {\r\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\r\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\r\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\r\n     * It's faster, but should only be used when you don't care about\r\n     * an exposed private key e.g. sig verification, which works over *public* keys.\r\n     */\r\n    multiplyUnsafe(n: bigint): Point {\r\n      const I = Point.ZERO;\r\n      if (n === _0n) return I;\r\n      assertGE(n); // Will throw on 0\r\n      if (n === _1n) return this;\r\n      const { endo } = CURVE;\r\n      if (!endo) return wnaf.unsafeLadder(this, n);\r\n\r\n      // Apply endomorphism\r\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\r\n      let k1p = I;\r\n      let k2p = I;\r\n      let d: Point = this;\r\n      while (k1 > _0n || k2 > _0n) {\r\n        if (k1 & _1n) k1p = k1p.add(d);\r\n        if (k2 & _1n) k2p = k2p.add(d);\r\n        d = d.double();\r\n        k1 >>= _1n;\r\n        k2 >>= _1n;\r\n      }\r\n      if (k1neg) k1p = k1p.negate();\r\n      if (k2neg) k2p = k2p.negate();\r\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\r\n      return k1p.add(k2p);\r\n    }\r\n\r\n    /**\r\n     * Constant time multiplication.\r\n     * Uses wNAF method. Windowed method may be 10% faster,\r\n     * but takes 2x longer to generate and consumes 2x memory.\r\n     * Uses precomputes when available.\r\n     * Uses endomorphism for Koblitz curves.\r\n     * @param scalar by which the point would be multiplied\r\n     * @returns New point\r\n     */\r\n    multiply(scalar: bigint): Point {\r\n      assertGE(scalar);\r\n      let n = scalar;\r\n      let point: Point, fake: Point; // Fake point is used to const-time mult\r\n      const { endo } = CURVE;\r\n      if (endo) {\r\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\r\n        let { p: k1p, f: f1p } = this.wNAF(k1);\r\n        let { p: k2p, f: f2p } = this.wNAF(k2);\r\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\r\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\r\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\r\n        point = k1p.add(k2p);\r\n        fake = f1p.add(f2p);\r\n      } else {\r\n        const { p, f } = this.wNAF(n);\r\n        point = p;\r\n        fake = f;\r\n      }\r\n      // Normalize `z` for both points, but return only real one\r\n      return Point.normalizeZ([point, fake])[0];\r\n    }\r\n\r\n    /**\r\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\r\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\r\n     * The trick could be useful if both P and Q are not G (not in our case).\r\n     * @returns non-zero affine point\r\n     */\r\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\r\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\r\n      const mul = (\r\n        P: Point,\r\n        a: bigint // Select faster multiply() method\r\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\r\n      const sum = mul(this, a).add(mul(Q, b));\r\n      return sum.is0() ? undefined : sum;\r\n    }\r\n\r\n    // Converts Projective point to affine (x, y) coordinates.\r\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\r\n    // (x, y, z) ‚àã (x=x/z, y=y/z)\r\n    toAffine(iz?: T): AffinePoint<T> {\r\n      const { px: x, py: y, pz: z } = this;\r\n      const is0 = this.is0();\r\n      // If invZ was 0, we return zero point. However we still want to execute\r\n      // all operations, so we replace invZ with a random number, 1.\r\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\r\n      const ax = Fp.mul(x, iz);\r\n      const ay = Fp.mul(y, iz);\r\n      const zz = Fp.mul(z, iz);\r\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\r\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\r\n      return { x: ax, y: ay };\r\n    }\r\n    isTorsionFree(): boolean {\r\n      const { h: cofactor, isTorsionFree } = CURVE;\r\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\r\n      if (isTorsionFree) return isTorsionFree(Point, this);\r\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\r\n    }\r\n    clearCofactor(): Point {\r\n      const { h: cofactor, clearCofactor } = CURVE;\r\n      if (cofactor === _1n) return this; // Fast-path\r\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\r\n      return this.multiplyUnsafe(CURVE.h);\r\n    }\r\n\r\n    toRawBytes(isCompressed = true): Uint8Array {\r\n      this.assertValidity();\r\n      return toBytes(Point, this, isCompressed);\r\n    }\r\n\r\n    toHex(isCompressed = true): string {\r\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\r\n    }\r\n  }\r\n  const _bits = CURVE.nBitLength;\r\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\r\n  // Validate if generator point is on curve\r\n  return {\r\n    CURVE,\r\n    ProjectivePoint: Point as ProjConstructor<T>,\r\n    normPrivateKeyToScalar,\r\n    weierstrassEquation,\r\n    isWithinCurveOrder,\r\n  };\r\n}\r\n\r\n// Instance\r\nexport interface SignatureType {\r\n  readonly r: bigint;\r\n  readonly s: bigint;\r\n  readonly recovery?: number;\r\n  assertValidity(): void;\r\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\r\n  hasHighS(): boolean;\r\n  normalizeS(): SignatureType;\r\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\r\n  toCompactRawBytes(): Uint8Array;\r\n  toCompactHex(): string;\r\n  // DER-encoded\r\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\r\n  toDERHex(isCompressed?: boolean): string;\r\n}\r\nexport type RecoveredSignatureType = SignatureType & {\r\n  readonly recovery: number;\r\n};\r\n// Static methods\r\nexport type SignatureConstructor = {\r\n  new (r: bigint, s: bigint): SignatureType;\r\n  fromCompact(hex: Hex): SignatureType;\r\n  fromDER(hex: Hex): SignatureType;\r\n};\r\ntype SignatureLike = { r: bigint; s: bigint };\r\n\r\nexport type PubKey = Hex | ProjPointType<bigint>;\r\n\r\nexport type CurveType = BasicWCurve<bigint> & {\r\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\r\n  hmac: HmacFnSync;\r\n  randomBytes: (bytesLength?: number) => Uint8Array;\r\n  lowS?: boolean;\r\n  bits2int?: (bytes: Uint8Array) => bigint;\r\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\r\n};\r\n\r\nfunction validateOpts(curve: CurveType) {\r\n  const opts = validateBasic(curve);\r\n  ut.validateObject(\r\n    opts,\r\n    {\r\n      hash: 'hash',\r\n      hmac: 'function',\r\n      randomBytes: 'function',\r\n    },\r\n    {\r\n      bits2int: 'function',\r\n      bits2int_modN: 'function',\r\n      lowS: 'boolean',\r\n    }\r\n  );\r\n  return Object.freeze({ lowS: true, ...opts } as const);\r\n}\r\n\r\nexport type CurveFn = {\r\n  CURVE: ReturnType<typeof validateOpts>;\r\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\r\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\r\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\r\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\r\n  ProjectivePoint: ProjConstructor<bigint>;\r\n  Signature: SignatureConstructor;\r\n  utils: {\r\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\r\n    isValidPrivateKey(privateKey: PrivKey): boolean;\r\n    randomPrivateKey: () => Uint8Array;\r\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\r\n  };\r\n};\r\n\r\nexport function weierstrass(curveDef: CurveType): CurveFn {\r\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\r\n  const { Fp, n: CURVE_ORDER } = CURVE;\r\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\r\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\r\n\r\n  function isValidFieldElement(num: bigint): boolean {\r\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\r\n  }\r\n  function modN(a: bigint) {\r\n    return mod.mod(a, CURVE_ORDER);\r\n  }\r\n  function invN(a: bigint) {\r\n    return mod.invert(a, CURVE_ORDER);\r\n  }\r\n\r\n  const {\r\n    ProjectivePoint: Point,\r\n    normPrivateKeyToScalar,\r\n    weierstrassEquation,\r\n    isWithinCurveOrder,\r\n  } = weierstrassPoints({\r\n    ...CURVE,\r\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\r\n      const a = point.toAffine();\r\n      const x = Fp.toBytes(a.x);\r\n      const cat = ut.concatBytes;\r\n      if (isCompressed) {\r\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\r\n      } else {\r\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\r\n      }\r\n    },\r\n    fromBytes(bytes: Uint8Array) {\r\n      const len = bytes.length;\r\n      const head = bytes[0];\r\n      const tail = bytes.subarray(1);\r\n      // this.assertValidity() is done inside of fromHex\r\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\r\n        const x = ut.bytesToNumberBE(tail);\r\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\r\n        const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\r\n        let y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\r\n        const isYOdd = (y & _1n) === _1n;\r\n        // ECDSA\r\n        const isHeadOdd = (head & 1) === 1;\r\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\r\n        return { x, y };\r\n      } else if (len === uncompressedLen && head === 0x04) {\r\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\r\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\r\n        return { x, y };\r\n      } else {\r\n        throw new Error(\r\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\r\n        );\r\n      }\r\n    },\r\n  });\r\n  const numToNByteStr = (num: bigint): string =>\r\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\r\n\r\n  function isBiggerThanHalfOrder(number: bigint) {\r\n    const HALF = CURVE_ORDER >> _1n;\r\n    return number > HALF;\r\n  }\r\n\r\n  function normalizeS(s: bigint) {\r\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\r\n  }\r\n  // slice bytes num\r\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\r\n\r\n  /**\r\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\r\n   */\r\n  class Signature implements SignatureType {\r\n    constructor(\r\n      readonly r: bigint,\r\n      readonly s: bigint,\r\n      readonly recovery?: number\r\n    ) {\r\n      this.assertValidity();\r\n    }\r\n\r\n    // pair (bytes of r, bytes of s)\r\n    static fromCompact(hex: Hex) {\r\n      const l = CURVE.nByteLength;\r\n      hex = ensureBytes('compactSignature', hex, l * 2);\r\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\r\n    }\r\n\r\n    // DER encoded ECDSA signature\r\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\r\n    static fromDER(hex: Hex) {\r\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\r\n      return new Signature(r, s);\r\n    }\r\n\r\n    assertValidity(): void {\r\n      // can use assertGE here\r\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\r\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\r\n    }\r\n\r\n    addRecoveryBit(recovery: number): RecoveredSignature {\r\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\r\n    }\r\n\r\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\r\n      const { r, s, recovery: rec } = this;\r\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\r\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\r\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\r\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\r\n      const prefix = (rec & 1) === 0 ? '02' : '03';\r\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\r\n      const ir = invN(radj); // r^-1\r\n      const u1 = modN(-h * ir); // -hr^-1\r\n      const u2 = modN(s * ir); // sr^-1\r\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\r\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\r\n      Q.assertValidity();\r\n      return Q;\r\n    }\r\n\r\n    // Signatures should be low-s, to prevent malleability.\r\n    hasHighS(): boolean {\r\n      return isBiggerThanHalfOrder(this.s);\r\n    }\r\n\r\n    normalizeS() {\r\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\r\n    }\r\n\r\n    // DER-encoded\r\n    toDERRawBytes() {\r\n      return ut.hexToBytes(this.toDERHex());\r\n    }\r\n    toDERHex() {\r\n      return DER.hexFromSig({ r: this.r, s: this.s });\r\n    }\r\n\r\n    // padded bytes of r, then padded bytes of s\r\n    toCompactRawBytes() {\r\n      return ut.hexToBytes(this.toCompactHex());\r\n    }\r\n    toCompactHex() {\r\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\r\n    }\r\n  }\r\n  type RecoveredSignature = Signature & { recovery: number };\r\n\r\n  const utils = {\r\n    isValidPrivateKey(privateKey: PrivKey) {\r\n      try {\r\n        normPrivateKeyToScalar(privateKey);\r\n        return true;\r\n      } catch (error) {\r\n        return false;\r\n      }\r\n    },\r\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\r\n\r\n    /**\r\n     * Produces cryptographically secure private key from random of size\r\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\r\n     */\r\n    randomPrivateKey: (): Uint8Array => {\r\n      const length = mod.getMinHashLength(CURVE.n);\r\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\r\n    },\r\n\r\n    /**\r\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\r\n     * Allows to massively speed-up `point.multiply(scalar)`.\r\n     * @returns cached point\r\n     * @example\r\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\r\n     * fast.multiply(privKey); // much faster ECDH now\r\n     */\r\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\r\n      point._setWindowSize(windowSize);\r\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\r\n      return point;\r\n    },\r\n  };\r\n\r\n  /**\r\n   * Computes public key for a private key. Checks for validity of the private key.\r\n   * @param privateKey private key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\r\n   */\r\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\r\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\r\n  }\r\n\r\n  /**\r\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\r\n   */\r\n  function isProbPub(item: PrivKey | PubKey): boolean {\r\n    const arr = ut.isBytes(item);\r\n    const str = typeof item === 'string';\r\n    const len = (arr || str) && (item as Hex).length;\r\n    if (arr) return len === compressedLen || len === uncompressedLen;\r\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\r\n    if (item instanceof Point) return true;\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * ECDH (Elliptic Curve Diffie Hellman).\r\n   * Computes shared public key from private key and public key.\r\n   * Checks: 1) private key validity 2) shared key is on-curve.\r\n   * Does NOT hash the result.\r\n   * @param privateA private key\r\n   * @param publicB different public key\r\n   * @param isCompressed whether to return compact (default), or full key\r\n   * @returns shared public key\r\n   */\r\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\r\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\r\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\r\n    const b = Point.fromHex(publicB); // check for being on-curve\r\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\r\n  }\r\n\r\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\r\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\r\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\r\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\r\n  const bits2int =\r\n    CURVE.bits2int ||\r\n    function (bytes: Uint8Array): bigint {\r\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\r\n      // for some cases, since bytes.length * 8 is not actual bitLength.\r\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\r\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\r\n      return delta > 0 ? num >> BigInt(delta) : num;\r\n    };\r\n  const bits2int_modN =\r\n    CURVE.bits2int_modN ||\r\n    function (bytes: Uint8Array): bigint {\r\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\r\n    };\r\n  // NOTE: pads output with zero as per spec\r\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\r\n  /**\r\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\r\n   */\r\n  function int2octets(num: bigint): Uint8Array {\r\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\r\n    if (!(_0n <= num && num < ORDER_MASK))\r\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\r\n    // works with order, can have different size than numToField!\r\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\r\n  }\r\n\r\n  // Steps A, D of RFC6979 3.2\r\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\r\n  // Used only in sign, not in verify.\r\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\r\n  // Also it can be bigger for P224 + SHA256\r\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\r\n    if (['recovered', 'canonical'].some((k) => k in opts))\r\n      throw new Error('sign() legacy options not supported');\r\n    const { hash, randomBytes } = CURVE;\r\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\r\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\r\n    msgHash = ensureBytes('msgHash', msgHash);\r\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\r\n\r\n    // We can't later call bits2octets, since nested bits2int is broken for curves\r\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\r\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\r\n    const h1int = bits2int_modN(msgHash);\r\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\r\n    const seedArgs = [int2octets(d), int2octets(h1int)];\r\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\r\n    if (ent != null) {\r\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\r\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\r\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\r\n    }\r\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\r\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\r\n    // Converts signature params into point w r/s, checks result for validity.\r\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\r\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\r\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\r\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\r\n      const ik = invN(k); // k^-1 mod n\r\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\r\n      const r = modN(q.x); // r = q.x mod n\r\n      if (r === _0n) return;\r\n      // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\r\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\r\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\r\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\r\n      if (s === _0n) return;\r\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\r\n      let normS = s;\r\n      if (lowS && isBiggerThanHalfOrder(s)) {\r\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\r\n        recovery ^= 1; // // in the bottom half of N\r\n      }\r\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\r\n    }\r\n    return { seed, k2sig };\r\n  }\r\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\r\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\r\n\r\n  /**\r\n   * Signs message hash with a private key.\r\n   * ```\r\n   * sign(m, d, k) where\r\n   *   (x, y) = G √ó k\r\n   *   r = x mod n\r\n   *   s = (m + dr)/k mod n\r\n   * ```\r\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\r\n   * @param privKey private key\r\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\r\n   * @returns signature with recovery param\r\n   */\r\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\r\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\r\n    const C = CURVE;\r\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\r\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\r\n  }\r\n\r\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\r\n  Point.BASE._setWindowSize(8);\r\n  // utils.precompute(8, ProjectivePoint.BASE)\r\n\r\n  /**\r\n   * Verifies a signature against message hash and public key.\r\n   * Rejects lowS signatures by default: to override,\r\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\r\n   *\r\n   * ```\r\n   * verify(r, s, h, P) where\r\n   *   U1 = hs^-1 mod n\r\n   *   U2 = rs^-1 mod n\r\n   *   R = U1‚ãÖG - U2‚ãÖP\r\n   *   mod(R.x, n) == r\r\n   * ```\r\n   */\r\n  function verify(\r\n    signature: Hex | SignatureLike,\r\n    msgHash: Hex,\r\n    publicKey: Hex,\r\n    opts = defaultVerOpts\r\n  ): boolean {\r\n    const sg = signature;\r\n    msgHash = ensureBytes('msgHash', msgHash);\r\n    publicKey = ensureBytes('publicKey', publicKey);\r\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\r\n    const { lowS, prehash } = opts;\r\n\r\n    let _sig: Signature | undefined = undefined;\r\n    let P: ProjPointType<bigint>;\r\n    try {\r\n      if (typeof sg === 'string' || ut.isBytes(sg)) {\r\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\r\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\r\n        try {\r\n          _sig = Signature.fromDER(sg);\r\n        } catch (derError) {\r\n          if (!(derError instanceof DER.Err)) throw derError;\r\n          _sig = Signature.fromCompact(sg);\r\n        }\r\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\r\n        const { r, s } = sg;\r\n        _sig = new Signature(r, s);\r\n      } else {\r\n        throw new Error('PARSE');\r\n      }\r\n      P = Point.fromHex(publicKey);\r\n    } catch (error) {\r\n      if ((error as Error).message === 'PARSE')\r\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\r\n      return false;\r\n    }\r\n    if (lowS && _sig.hasHighS()) return false;\r\n    if (prehash) msgHash = CURVE.hash(msgHash);\r\n    const { r, s } = _sig;\r\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\r\n    const is = invN(s); // s^-1\r\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\r\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\r\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\r\n    if (!R) return false;\r\n    const v = modN(R.x);\r\n    return v === r;\r\n  }\r\n  return {\r\n    CURVE,\r\n    getPublicKey,\r\n    getSharedSecret,\r\n    sign,\r\n    verify,\r\n    ProjectivePoint: Point,\r\n    Signature,\r\n    utils,\r\n  };\r\n}\r\n\r\n/**\r\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\r\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\r\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\r\n * b = False and y = sqrt(Z * (u / v)) otherwise.\r\n * @param Fp\r\n * @param Z\r\n * @returns\r\n */\r\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\r\n  // Generic implementation\r\n  const q = Fp.ORDER;\r\n  let l = _0n;\r\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\r\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\r\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\r\n  // 2n ** c1 == 2n << (c1-1)\r\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\r\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\r\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\r\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\r\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\r\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\r\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\r\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\r\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\r\n    let tv1 = c6; // 1. tv1 = c6\r\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\r\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\r\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\r\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\r\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\r\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\r\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\r\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\r\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\r\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\r\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\r\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\r\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\r\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\r\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\r\n    // 17. for i in (c1, c1 - 1, ..., 2):\r\n    for (let i = c1; i > _1n; i--) {\r\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\r\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\r\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\r\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\r\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\r\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\r\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\r\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\r\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\r\n    }\r\n    return { isValid: isQR, value: tv3 };\r\n  };\r\n  if (Fp.ORDER % _4n === _3n) {\r\n    // sqrt_ratio_3mod4(u, v)\r\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\r\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\r\n    sqrtRatio = (u: T, v: T) => {\r\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\r\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\r\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\r\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\r\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\r\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\r\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\r\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\r\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\r\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\r\n    };\r\n  }\r\n  // No curves uses that\r\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\r\n  return sqrtRatio;\r\n}\r\n/**\r\n * Simplified Shallue-van de Woestijne-Ulas Method\r\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\r\n */\r\nexport function mapToCurveSimpleSWU<T>(\r\n  Fp: mod.IField<T>,\r\n  opts: {\r\n    A: T;\r\n    B: T;\r\n    Z: T;\r\n  }\r\n) {\r\n  mod.validateField(Fp);\r\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\r\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\r\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\r\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\r\n  // Input: u, an element of F.\r\n  // Output: (x, y), a point on E.\r\n  return (u: T): { x: T; y: T } => {\r\n    // prettier-ignore\r\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\r\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\r\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\r\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\r\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\r\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\r\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\r\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\r\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\r\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\r\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\r\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\r\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\r\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\r\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\r\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\r\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\r\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\r\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\r\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\r\n    y = Fp.mul(y, value); // 20.   y = y * y1\r\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\r\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\r\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\r\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\r\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\r\n    return { x, y };\r\n  };\r\n}\r\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n/**\r\n * BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\r\n * Implements BLS (Boneh-Lynn-Shacham) signatures.\r\n * Consists of two curves: G1 and G2:\r\n * - G1 is a subgroup of (x, y) E(Fq) over y¬≤ = x¬≥ + 4.\r\n * - G2 is a subgroup of ((x‚ÇÅ, x‚ÇÇ+i), (y‚ÇÅ, y‚ÇÇ+i)) E(Fq¬≤) over y¬≤ = x¬≥ + 4(1 + i) where i is ‚àö-1\r\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\r\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\r\n * Pairing is used to aggregate and verify signatures.\r\n * We are using Fp for private keys (shorter) and Fp‚ÇÇ for signatures (longer).\r\n * Some projects may prefer to swap this relation, it is not supported for now.\r\n */\r\nimport { AffinePoint } from './curve.js';\r\nimport { IField, getMinHashLength, mapHashToField } from './modular.js';\r\nimport { Hex, PrivKey, CHash, bitLen, bitGet, ensureBytes } from './utils.js';\r\n// prettier-ignore\r\nimport {\r\n  MapToCurve, Opts as HTFOpts, H2CPointConstructor, htfBasicOpts,\r\n  createHasher\r\n} from './hash-to-curve.js';\r\nimport {\r\n  CurvePointsType,\r\n  ProjPointType as ProjPointType,\r\n  CurvePointsRes,\r\n  weierstrassPoints,\r\n} from './weierstrass.js';\r\n\r\ntype Fp = bigint; // Can be different field?\r\n\r\n// prettier-ignore\r\nconst _2n = BigInt(2), _3n = BigInt(3);\r\n\r\nexport type ShortSignatureCoder<Fp> = {\r\n  fromHex(hex: Hex): ProjPointType<Fp>;\r\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\r\n  toHex(point: ProjPointType<Fp>): string;\r\n};\r\n\r\nexport type SignatureCoder<Fp2> = {\r\n  fromHex(hex: Hex): ProjPointType<Fp2>;\r\n  toRawBytes(point: ProjPointType<Fp2>): Uint8Array;\r\n  toHex(point: ProjPointType<Fp2>): string;\r\n};\r\n\r\nexport type CurveType<Fp, Fp2, Fp6, Fp12> = {\r\n  G1: Omit<CurvePointsType<Fp>, 'n'> & {\r\n    ShortSignature: SignatureCoder<Fp>;\r\n    mapToCurve: MapToCurve<Fp>;\r\n    htfDefaults: HTFOpts;\r\n  };\r\n  G2: Omit<CurvePointsType<Fp2>, 'n'> & {\r\n    Signature: SignatureCoder<Fp2>;\r\n    mapToCurve: MapToCurve<Fp2>;\r\n    htfDefaults: HTFOpts;\r\n  };\r\n  fields: {\r\n    Fp: IField<Fp>;\r\n    Fr: IField<bigint>;\r\n    Fp2: IField<Fp2> & {\r\n      reim: (num: Fp2) => { re: bigint; im: bigint };\r\n      multiplyByB: (num: Fp2) => Fp2;\r\n      frobeniusMap(num: Fp2, power: number): Fp2;\r\n    };\r\n    Fp6: IField<Fp6>;\r\n    Fp12: IField<Fp12> & {\r\n      frobeniusMap(num: Fp12, power: number): Fp12;\r\n      multiplyBy014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\r\n      conjugate(num: Fp12): Fp12;\r\n      finalExponentiate(num: Fp12): Fp12;\r\n    };\r\n  };\r\n  params: {\r\n    x: bigint;\r\n    r: bigint;\r\n  };\r\n  htfDefaults: HTFOpts;\r\n  hash: CHash; // Because we need outputLen for DRBG\r\n  randomBytes: (bytesLength?: number) => Uint8Array;\r\n};\r\n\r\nexport type CurveFn<Fp, Fp2, Fp6, Fp12> = {\r\n  getPublicKey: (privateKey: PrivKey) => Uint8Array;\r\n  getPublicKeyForShortSignatures: (privateKey: PrivKey) => Uint8Array;\r\n  sign: {\r\n    (message: Hex, privateKey: PrivKey): Uint8Array;\r\n    (message: ProjPointType<Fp2>, privateKey: PrivKey): ProjPointType<Fp2>;\r\n  };\r\n  signShortSignature: {\r\n    (message: Hex, privateKey: PrivKey): Uint8Array;\r\n    (message: ProjPointType<Fp>, privateKey: PrivKey): ProjPointType<Fp>;\r\n  };\r\n  verify: (\r\n    signature: Hex | ProjPointType<Fp2>,\r\n    message: Hex | ProjPointType<Fp2>,\r\n    publicKey: Hex | ProjPointType<Fp>,\r\n    htfOpts?: htfBasicOpts\r\n  ) => boolean;\r\n  verifyShortSignature: (\r\n    signature: Hex | ProjPointType<Fp>,\r\n    message: Hex | ProjPointType<Fp>,\r\n    publicKey: Hex | ProjPointType<Fp2>,\r\n    htfOpts?: htfBasicOpts\r\n  ) => boolean;\r\n  verifyBatch: (\r\n    signature: Hex | ProjPointType<Fp2>,\r\n    messages: (Hex | ProjPointType<Fp2>)[],\r\n    publicKeys: (Hex | ProjPointType<Fp>)[],\r\n    htfOpts?: htfBasicOpts\r\n  ) => boolean;\r\n  aggregatePublicKeys: {\r\n    (publicKeys: Hex[]): Uint8Array;\r\n    (publicKeys: ProjPointType<Fp>[]): ProjPointType<Fp>;\r\n  };\r\n  aggregateSignatures: {\r\n    (signatures: Hex[]): Uint8Array;\r\n    (signatures: ProjPointType<Fp2>[]): ProjPointType<Fp2>;\r\n  };\r\n  aggregateShortSignatures: {\r\n    (signatures: Hex[]): Uint8Array;\r\n    (signatures: ProjPointType<Fp>[]): ProjPointType<Fp>;\r\n  };\r\n  millerLoop: (ell: [Fp2, Fp2, Fp2][], g1: [Fp, Fp]) => Fp12;\r\n  pairing: (P: ProjPointType<Fp>, Q: ProjPointType<Fp2>, withFinalExponent?: boolean) => Fp12;\r\n  G1: CurvePointsRes<Fp> & ReturnType<typeof createHasher<Fp>>;\r\n  G2: CurvePointsRes<Fp2> & ReturnType<typeof createHasher<Fp2>>;\r\n  Signature: SignatureCoder<Fp2>;\r\n  ShortSignature: ShortSignatureCoder<Fp>;\r\n  params: {\r\n    x: bigint;\r\n    r: bigint;\r\n    G1b: bigint;\r\n    G2b: Fp2;\r\n  };\r\n  fields: {\r\n    Fp: IField<Fp>;\r\n    Fp2: IField<Fp2>;\r\n    Fp6: IField<Fp6>;\r\n    Fp12: IField<Fp12>;\r\n    Fr: IField<bigint>;\r\n  };\r\n  utils: {\r\n    randomPrivateKey: () => Uint8Array;\r\n    calcPairingPrecomputes: (p: AffinePoint<Fp2>) => [Fp2, Fp2, Fp2][];\r\n  };\r\n};\r\n\r\nexport function bls<Fp2, Fp6, Fp12>(\r\n  CURVE: CurveType<Fp, Fp2, Fp6, Fp12>\r\n): CurveFn<Fp, Fp2, Fp6, Fp12> {\r\n  // Fields are specific for curve, so for now we'll need to pass them with opts\r\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\r\n  const BLS_X_LEN = bitLen(CURVE.params.x);\r\n\r\n  // Pre-compute coefficients for sparse multiplication\r\n  // Point addition and point double calculations is reused for coefficients\r\n  function calcPairingPrecomputes(p: AffinePoint<Fp2>) {\r\n    const { x, y } = p;\r\n    // prettier-ignore\r\n    const Qx = x, Qy = y, Qz = Fp2.ONE;\r\n    // prettier-ignore\r\n    let Rx = Qx, Ry = Qy, Rz = Qz;\r\n    let ell_coeff: [Fp2, Fp2, Fp2][] = [];\r\n    for (let i = BLS_X_LEN - 2; i >= 0; i--) {\r\n      // Double\r\n      let t0 = Fp2.sqr(Ry); // Ry¬≤\r\n      let t1 = Fp2.sqr(Rz); // Rz¬≤\r\n      let t2 = Fp2.multiplyByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\r\n      let t3 = Fp2.mul(t2, _3n); // 3 * T2\r\n      let t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)¬≤ - T1 - T0\r\n      ell_coeff.push([\r\n        Fp2.sub(t2, t0), // T2 - T0\r\n        Fp2.mul(Fp2.sqr(Rx), _3n), // 3 * Rx¬≤\r\n        Fp2.neg(t4), // -T4\r\n      ]);\r\n      Rx = Fp2.div(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2\r\n      Ry = Fp2.sub(Fp2.sqr(Fp2.div(Fp2.add(t0, t3), _2n)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)¬≤ - 3 * T2¬≤\r\n      Rz = Fp2.mul(t0, t4); // T0 * T4\r\n      if (bitGet(CURVE.params.x, i)) {\r\n        // Addition\r\n        let t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\r\n        let t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\r\n        ell_coeff.push([\r\n          Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)), // T0 * Qx - T1 * Qy\r\n          Fp2.neg(t0), // -T0\r\n          t1, // T1\r\n        ]);\r\n        let t2 = Fp2.sqr(t1); // T1¬≤\r\n        let t3 = Fp2.mul(t2, t1); // T2 * T1\r\n        let t4 = Fp2.mul(t2, Rx); // T2 * Rx\r\n        let t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0¬≤ * Rz\r\n        Rx = Fp2.mul(t1, t5); // T1 * T5\r\n        Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\r\n        Rz = Fp2.mul(Rz, t3); // Rz * T3\r\n      }\r\n    }\r\n    return ell_coeff;\r\n  }\r\n\r\n  function millerLoop(ell: [Fp2, Fp2, Fp2][], g1: [Fp, Fp]): Fp12 {\r\n    const { x } = CURVE.params;\r\n    const Px = g1[0];\r\n    const Py = g1[1];\r\n    let f12 = Fp12.ONE;\r\n    for (let j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++) {\r\n      const E = ell[j];\r\n      f12 = Fp12.multiplyBy014(f12, E[0], Fp2.mul(E[1], Px), Fp2.mul(E[2], Py));\r\n      if (bitGet(x, i)) {\r\n        j += 1;\r\n        const F = ell[j];\r\n        f12 = Fp12.multiplyBy014(f12, F[0], Fp2.mul(F[1], Px), Fp2.mul(F[2], Py));\r\n      }\r\n      if (i !== 0) f12 = Fp12.sqr(f12);\r\n    }\r\n    return Fp12.conjugate(f12);\r\n  }\r\n\r\n  const utils = {\r\n    randomPrivateKey: (): Uint8Array => {\r\n      const length = getMinHashLength(Fr.ORDER);\r\n      return mapHashToField(CURVE.randomBytes(length), Fr.ORDER);\r\n    },\r\n    calcPairingPrecomputes,\r\n  };\r\n\r\n  // Point on G1 curve: (x, y)\r\n  const G1_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G1 });\r\n  const G1 = Object.assign(\r\n    G1_,\r\n    createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\r\n      ...CURVE.htfDefaults,\r\n      ...CURVE.G1.htfDefaults,\r\n    })\r\n  );\r\n\r\n  // Sparse multiplication against precomputed coefficients\r\n  // TODO: replace with weakmap?\r\n  type withPairingPrecomputes = { _PPRECOMPUTES: [Fp2, Fp2, Fp2][] | undefined };\r\n  function pairingPrecomputes(point: G2): [Fp2, Fp2, Fp2][] {\r\n    const p = point as G2 & withPairingPrecomputes;\r\n    if (p._PPRECOMPUTES) return p._PPRECOMPUTES;\r\n    p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());\r\n    return p._PPRECOMPUTES;\r\n  }\r\n\r\n  // TODO: export\r\n  // function clearPairingPrecomputes(point: G2) {\r\n  //   const p = point as G2 & withPairingPrecomputes;\r\n  //   p._PPRECOMPUTES = undefined;\r\n  // }\r\n\r\n  // Point on G2 curve (complex numbers): (x‚ÇÅ, x‚ÇÇ+i), (y‚ÇÅ, y‚ÇÇ+i)\r\n  const G2_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G2 });\r\n  const G2 = Object.assign(\r\n    G2_,\r\n    createHasher(G2_.ProjectivePoint as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\r\n      ...CURVE.htfDefaults,\r\n      ...CURVE.G2.htfDefaults,\r\n    })\r\n  );\r\n\r\n  const { ShortSignature } = CURVE.G1;\r\n  const { Signature } = CURVE.G2;\r\n\r\n  // Calculates bilinear pairing\r\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\r\n    if (Q.equals(G1.ProjectivePoint.ZERO) || P.equals(G2.ProjectivePoint.ZERO))\r\n      throw new Error('pairing is not available for ZERO point');\r\n    Q.assertValidity();\r\n    P.assertValidity();\r\n    // Performance: 9ms for millerLoop and ~14ms for exp.\r\n    const Qa = Q.toAffine();\r\n    const looped = millerLoop(pairingPrecomputes(P), [Qa.x, Qa.y]);\r\n    return withFinalExponent ? Fp12.finalExponentiate(looped) : looped;\r\n  }\r\n  type G1 = typeof G1.ProjectivePoint.BASE;\r\n  type G2 = typeof G2.ProjectivePoint.BASE;\r\n\r\n  type G1Hex = Hex | G1;\r\n  type G2Hex = Hex | G2;\r\n  function normP1(point: G1Hex): G1 {\r\n    return point instanceof G1.ProjectivePoint ? (point as G1) : G1.ProjectivePoint.fromHex(point);\r\n  }\r\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\r\n    return point instanceof G1.ProjectivePoint\r\n      ? point\r\n      : (G1.hashToCurve(ensureBytes('point', point), htfOpts) as G1);\r\n  }\r\n  function normP2(point: G2Hex): G2 {\r\n    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\r\n  }\r\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\r\n    return point instanceof G2.ProjectivePoint\r\n      ? point\r\n      : (G2.hashToCurve(ensureBytes('point', point), htfOpts) as G2);\r\n  }\r\n\r\n  // Multiplies generator (G1) by private key.\r\n  // P = pk x G\r\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\r\n    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\r\n  }\r\n\r\n  // Multiplies generator (G2) by private key.\r\n  // P = pk x G\r\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\r\n    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\r\n  }\r\n\r\n  // Executes `hashToCurve` on the message and then multiplies the result by private key.\r\n  // S = pk x H(m)\r\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\r\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\r\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\r\n    const msgPoint = normP2Hash(message, htfOpts);\r\n    msgPoint.assertValidity();\r\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\r\n    if (message instanceof G2.ProjectivePoint) return sigPoint;\r\n    return Signature.toRawBytes(sigPoint);\r\n  }\r\n\r\n  function signShortSignature(\r\n    message: Hex,\r\n    privateKey: PrivKey,\r\n    htfOpts?: htfBasicOpts\r\n  ): Uint8Array;\r\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\r\n  function signShortSignature(\r\n    message: G1Hex,\r\n    privateKey: PrivKey,\r\n    htfOpts?: htfBasicOpts\r\n  ): Uint8Array | G1 {\r\n    const msgPoint = normP1Hash(message, htfOpts);\r\n    msgPoint.assertValidity();\r\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\r\n    if (message instanceof G1.ProjectivePoint) return sigPoint;\r\n    return ShortSignature.toRawBytes(sigPoint);\r\n  }\r\n\r\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\r\n  // e(P, H(m)) == e(G, S)\r\n  function verify(\r\n    signature: G2Hex,\r\n    message: G2Hex,\r\n    publicKey: G1Hex,\r\n    htfOpts?: htfBasicOpts\r\n  ): boolean {\r\n    const P = normP1(publicKey);\r\n    const Hm = normP2Hash(message, htfOpts);\r\n    const G = G1.ProjectivePoint.BASE;\r\n    const S = normP2(signature);\r\n    // Instead of doing 2 exponentiations, we use property of billinear maps\r\n    // and do one exp after multiplying 2 points.\r\n    const ePHm = pairing(P.negate(), Hm, false);\r\n    const eGS = pairing(G, S, false);\r\n    const exp = Fp12.finalExponentiate(Fp12.mul(eGS, ePHm));\r\n    return Fp12.eql(exp, Fp12.ONE);\r\n  }\r\n\r\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\r\n  // e(S, G) == e(H(m), P)\r\n  function verifyShortSignature(\r\n    signature: G1Hex,\r\n    message: G1Hex,\r\n    publicKey: G2Hex,\r\n    htfOpts?: htfBasicOpts\r\n  ): boolean {\r\n    const P = normP2(publicKey);\r\n    const Hm = normP1Hash(message, htfOpts);\r\n    const G = G2.ProjectivePoint.BASE;\r\n    const S = normP1(signature);\r\n    // Instead of doing 2 exponentiations, we use property of billinear maps\r\n    // and do one exp after multiplying 2 points.\r\n    const eHmP = pairing(Hm, P, false);\r\n    const eSG = pairing(S, G.negate(), false);\r\n    const exp = Fp12.finalExponentiate(Fp12.mul(eSG, eHmP));\r\n    return Fp12.eql(exp, Fp12.ONE);\r\n  }\r\n\r\n  // Adds a bunch of public key points together.\r\n  // pk1 + pk2 + pk3 = pkA\r\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\r\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\r\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\r\n    if (!publicKeys.length) throw new Error('Expected non-empty array');\r\n    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\r\n    const aggAffine = agg; //.toAffine();\r\n    if (publicKeys[0] instanceof G1.ProjectivePoint) {\r\n      aggAffine.assertValidity();\r\n      return aggAffine;\r\n    }\r\n    // toRawBytes ensures point validity\r\n    return aggAffine.toRawBytes(true);\r\n  }\r\n\r\n  // Adds a bunch of signature points together.\r\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\r\n  function aggregateSignatures(signatures: G2[]): G2;\r\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\r\n    if (!signatures.length) throw new Error('Expected non-empty array');\r\n    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\r\n    const aggAffine = agg; //.toAffine();\r\n    if (signatures[0] instanceof G2.ProjectivePoint) {\r\n      aggAffine.assertValidity();\r\n      return aggAffine;\r\n    }\r\n    return Signature.toRawBytes(aggAffine);\r\n  }\r\n\r\n  // Adds a bunch of signature points together.\r\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\r\n  function aggregateShortSignatures(signatures: G1[]): G1;\r\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\r\n    if (!signatures.length) throw new Error('Expected non-empty array');\r\n    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\r\n    const aggAffine = agg; //.toAffine();\r\n    if (signatures[0] instanceof G1.ProjectivePoint) {\r\n      aggAffine.assertValidity();\r\n      return aggAffine;\r\n    }\r\n    return ShortSignature.toRawBytes(aggAffine);\r\n  }\r\n\r\n  // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\r\n  // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\r\n  function verifyBatch(\r\n    signature: G2Hex,\r\n    messages: G2Hex[],\r\n    publicKeys: G1Hex[],\r\n    htfOpts?: htfBasicOpts\r\n  ): boolean {\r\n    // @ts-ignore\r\n    // console.log('verifyBatch', bytesToHex(signature as any), messages, publicKeys.map(bytesToHex));\r\n\r\n    if (!messages.length) throw new Error('Expected non-empty messages array');\r\n    if (publicKeys.length !== messages.length)\r\n      throw new Error('Pubkey count should equal msg count');\r\n    const sig = normP2(signature);\r\n    const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\r\n    const nPublicKeys = publicKeys.map(normP1);\r\n    try {\r\n      const paired = [];\r\n      for (const message of new Set(nMessages)) {\r\n        const groupPublicKey = nMessages.reduce(\r\n          (groupPublicKey, subMessage, i) =>\r\n            subMessage === message ? groupPublicKey.add(nPublicKeys[i]) : groupPublicKey,\r\n          G1.ProjectivePoint.ZERO\r\n        );\r\n        // const msg = message instanceof PointG2 ? message : await PointG2.hashToCurve(message);\r\n        // Possible to batch pairing for same msg with different groupPublicKey here\r\n        paired.push(pairing(groupPublicKey, message, false));\r\n      }\r\n      paired.push(pairing(G1.ProjectivePoint.BASE.negate(), sig, false));\r\n      const product = paired.reduce((a, b) => Fp12.mul(a, b), Fp12.ONE);\r\n      const exp = Fp12.finalExponentiate(product);\r\n      return Fp12.eql(exp, Fp12.ONE);\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  G1.ProjectivePoint.BASE._setWindowSize(4);\r\n\r\n  return {\r\n    getPublicKey,\r\n    getPublicKeyForShortSignatures,\r\n    sign,\r\n    signShortSignature,\r\n    verify,\r\n    verifyBatch,\r\n    verifyShortSignature,\r\n    aggregatePublicKeys,\r\n    aggregateSignatures,\r\n    aggregateShortSignatures,\r\n    millerLoop,\r\n    pairing,\r\n    G1,\r\n    G2,\r\n    Signature,\r\n    ShortSignature,\r\n    fields: {\r\n      Fr,\r\n      Fp,\r\n      Fp2,\r\n      Fp6,\r\n      Fp12,\r\n    },\r\n    params: {\r\n      x: CURVE.params.x,\r\n      r: CURVE.params.r,\r\n      G1b: CURVE.G1.b,\r\n      G2b: CURVE.G2.b,\r\n    },\r\n    utils,\r\n  };\r\n}\r\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\r\n\r\n// bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\r\n// - Construct zk-SNARKs at the 120-bit security\r\n// - Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\r\n//   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\r\n//\r\n// ### Summary\r\n// 1. BLS Relies on Bilinear Pairing (expensive)\r\n// 2. Private Keys: 32 bytes\r\n// 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\r\n// 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\r\n//     - The signature is a point on the G2 subgroup, which is defined over a finite field\r\n//     with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the complex numbers).\r\n// 5. The 12 stands for the Embedding degree.\r\n//\r\n// ### Formulas\r\n// - `P = pk x G` - public keys\r\n// - `S = pk x H(m)` - signing\r\n// - `e(P, H(m)) == e(G, S)` - verification using pairings\r\n// - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\r\n//\r\n// ### Compatibility and notes\r\n// 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC\r\n//    Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\r\n// 2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\"\r\n// 3. Curve security level is about 120 bits as per Barbulescu-Duquesne 2017\r\n//    https://hal.science/hal-01534101/file/main.pdf\r\n// 4. Compatible with specs:\r\n// [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\r\n// [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05),\r\n// [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport { randomBytes } from '@noble/hashes/utils';\r\nimport { bls, CurveFn } from './abstract/bls.js';\r\nimport * as mod from './abstract/modular.js';\r\nimport {\r\n  concatBytes as concatB,\r\n  ensureBytes,\r\n  numberToBytesBE,\r\n  bytesToNumberBE,\r\n  bitLen,\r\n  bitGet,\r\n  Hex,\r\n  bitMask,\r\n  bytesToHex,\r\n} from './abstract/utils.js';\r\n// Types\r\nimport {\r\n  ProjPointType,\r\n  ProjConstructor,\r\n  mapToCurveSimpleSWU,\r\n  AffinePoint,\r\n} from './abstract/weierstrass.js';\r\nimport { isogenyMap } from './abstract/hash-to-curve.js';\r\n\r\n// Be friendly to bad ECMAScript parsers by not using bigint literals\r\n// prettier-ignore\r\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\r\n// prettier-ignore\r\nconst _8n = BigInt(8), _16n = BigInt(16);\r\n\r\n// CURVE FIELDS\r\n// Finite field over p.\r\nconst Fp_raw = BigInt(\r\n  '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'\r\n);\r\nconst Fp = mod.Field(Fp_raw);\r\ntype Fp = bigint;\r\n// Finite field over r.\r\n// This particular field is not used anywhere in bls12-381, but it is still useful.\r\nconst Fr = mod.Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\r\n\r\n// Fp‚ÇÇ over complex plane\r\ntype BigintTuple = [bigint, bigint];\r\ntype Fp2 = { c0: bigint; c1: bigint };\r\nconst Fp2Add = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\r\n  c0: Fp.add(c0, r0),\r\n  c1: Fp.add(c1, r1),\r\n});\r\nconst Fp2Subtract = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\r\n  c0: Fp.sub(c0, r0),\r\n  c1: Fp.sub(c1, r1),\r\n});\r\nconst Fp2Multiply = ({ c0, c1 }: Fp2, rhs: Fp2) => {\r\n  if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\r\n  // (a+bi)(c+di) = (ac‚àíbd) + (ad+bc)i\r\n  const { c0: r0, c1: r1 } = rhs;\r\n  let t1 = Fp.mul(c0, r0); // c0 * o0\r\n  let t2 = Fp.mul(c1, r1); // c1 * o1\r\n  // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\r\n  const o0 = Fp.sub(t1, t2);\r\n  const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\r\n  return { c0: o0, c1: o1 };\r\n};\r\nconst Fp2Square = ({ c0, c1 }: Fp2) => {\r\n  const a = Fp.add(c0, c1);\r\n  const b = Fp.sub(c0, c1);\r\n  const c = Fp.add(c0, c0);\r\n  return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\r\n};\r\ntype Fp2Utils = {\r\n  fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\r\n  reim: (num: Fp2) => { re: bigint; im: bigint };\r\n  mulByNonresidue: (num: Fp2) => Fp2;\r\n  multiplyByB: (num: Fp2) => Fp2;\r\n  frobeniusMap(num: Fp2, power: number): Fp2;\r\n};\r\n// G2 is the order-q subgroup of E2(Fp¬≤) : y¬≤ = x¬≥+4(1+‚àö‚àí1),\r\n// where Fp2 is Fp[‚àö‚àí1]/(x2+1). #E2(Fp2 ) = h2q, where\r\n// G¬≤ - 1\r\n// h2q\r\n// NOTE: ORDER was wrong!\r\nconst FP2_ORDER = Fp_raw * Fp_raw;\r\n\r\nconst Fp2: mod.IField<Fp2> & Fp2Utils = {\r\n  ORDER: FP2_ORDER,\r\n  BITS: bitLen(FP2_ORDER),\r\n  BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\r\n  MASK: bitMask(bitLen(FP2_ORDER)),\r\n  ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\r\n  ONE: { c0: Fp.ONE, c1: Fp.ZERO },\r\n  create: (num) => num,\r\n  isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\r\n  is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\r\n  eql: ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\r\n  neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\r\n  pow: (num, power) => mod.FpPow(Fp2, num, power),\r\n  invertBatch: (nums) => mod.FpInvertBatch(Fp2, nums),\r\n  // Normalized\r\n  add: Fp2Add,\r\n  sub: Fp2Subtract,\r\n  mul: Fp2Multiply,\r\n  sqr: Fp2Square,\r\n  // NonNormalized stuff\r\n  addN: Fp2Add,\r\n  subN: Fp2Subtract,\r\n  mulN: Fp2Multiply,\r\n  sqrN: Fp2Square,\r\n  // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\r\n  div: (lhs, rhs) => Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\r\n  inv: ({ c0: a, c1: b }) => {\r\n    // We wish to find the multiplicative inverse of a nonzero\r\n    // element a + bu in Fp2. We leverage an identity\r\n    //\r\n    // (a + bu)(a - bu) = a¬≤ + b¬≤\r\n    //\r\n    // which holds because u¬≤ = -1. This can be rewritten as\r\n    //\r\n    // (a + bu)(a - bu)/(a¬≤ + b¬≤) = 1\r\n    //\r\n    // because a¬≤ + b¬≤ = 0 has no nonzero solutions for (a, b).\r\n    // This gives that (a - bu)/(a¬≤ + b¬≤) is the inverse\r\n    // of (a + bu). Importantly, this can be computing using\r\n    // only a single inversion in Fp.\r\n    const factor = Fp.inv(Fp.create(a * a + b * b));\r\n    return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\r\n  },\r\n  sqrt: (num) => {\r\n    if (Fp2.eql(num, Fp2.ZERO)) return Fp2.ZERO; // Algo doesn't handles this case\r\n    // TODO: Optimize this line. It's extremely slow.\r\n    // Speeding this up would boost aggregateSignatures.\r\n    // https://eprint.iacr.org/2012/685.pdf applicable?\r\n    // https://github.com/zkcrypto/bls12_381/blob/080eaa74ec0e394377caa1ba302c8c121df08b07/src/fp2.rs#L250\r\n    // https://github.com/supranational/blst/blob/aae0c7d70b799ac269ff5edf29d8191dbd357876/src/exp2.c#L1\r\n    // Inspired by https://github.com/dalek-cryptography/curve25519-dalek/blob/17698df9d4c834204f83a3574143abacb4fc81a5/src/field.rs#L99\r\n    const candidateSqrt = Fp2.pow(num, (Fp2.ORDER + _8n) / _16n);\r\n    const check = Fp2.div(Fp2.sqr(candidateSqrt), num); // candidateSqrt.square().div(this);\r\n    const R = FP2_ROOTS_OF_UNITY;\r\n    const divisor = [R[0], R[2], R[4], R[6]].find((r) => Fp2.eql(r, check));\r\n    if (!divisor) throw new Error('No root');\r\n    const index = R.indexOf(divisor);\r\n    const root = R[index / 2];\r\n    if (!root) throw new Error('Invalid root');\r\n    const x1 = Fp2.div(candidateSqrt, root);\r\n    const x2 = Fp2.neg(x1);\r\n    const { re: re1, im: im1 } = Fp2.reim(x1);\r\n    const { re: re2, im: im2 } = Fp2.reim(x2);\r\n    if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\r\n    return x2;\r\n  },\r\n  // Same as sgn0_m_eq_2 in RFC 9380\r\n  isOdd: (x: Fp2) => {\r\n    const { re: x0, im: x1 } = Fp2.reim(x);\r\n    const sign_0 = x0 % _2n;\r\n    const zero_0 = x0 === _0n;\r\n    const sign_1 = x1 % _2n;\r\n    return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\r\n  },\r\n  // Bytes util\r\n  fromBytes(b: Uint8Array): Fp2 {\r\n    if (b.length !== Fp2.BYTES) throw new Error(`fromBytes wrong length=${b.length}`);\r\n    return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\r\n  },\r\n  toBytes: ({ c0, c1 }) => concatB(Fp.toBytes(c0), Fp.toBytes(c1)),\r\n  cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\r\n    c0: Fp.cmov(c0, r0, c),\r\n    c1: Fp.cmov(c1, r1, c),\r\n  }),\r\n  // Specific utils\r\n  // toString() {\r\n  //   return `Fp2(${this.c0} + ${this.c1}√ói)`;\r\n  // }\r\n  reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\r\n  // multiply by u + 1\r\n  mulByNonresidue: ({ c0, c1 }) => ({ c0: Fp.sub(c0, c1), c1: Fp.add(c0, c1) }),\r\n  multiplyByB: ({ c0, c1 }) => {\r\n    let t0 = Fp.mul(c0, _4n); // 4 * c0\r\n    let t1 = Fp.mul(c1, _4n); // 4 * c1\r\n    // (T0-T1) + (T0+T1)*i\r\n    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\r\n  },\r\n  fromBigTuple: (tuple: BigintTuple | bigint[]) => {\r\n    if (tuple.length !== 2) throw new Error('Invalid tuple');\r\n    const fps = tuple.map((n) => Fp.create(n)) as [Fp, Fp];\r\n    return { c0: fps[0], c1: fps[1] };\r\n  },\r\n  frobeniusMap: ({ c0, c1 }, power: number): Fp2 => ({\r\n    c0,\r\n    c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\r\n  }),\r\n};\r\n// Finite extension field over irreducible polynominal.\r\n// Fp(u) / (u¬≤ - Œ≤) where Œ≤ = -1\r\nconst FP2_FROBENIUS_COEFFICIENTS = [\r\n  BigInt('0x1'),\r\n  BigInt(\r\n    '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'\r\n  ),\r\n].map((item) => Fp.create(item));\r\n\r\n// For Fp2 roots of unity.\r\nconst rv1 = BigInt(\r\n  '0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'\r\n);\r\n// const ev1 =\r\n//   BigInt('0x699be3b8c6870965e5bf892ad5d2cc7b0e85a117402dfd83b7f4a947e02d978498255a2aaec0ac627b5afbdf1bf1c90');\r\n// const ev2 =\r\n//   BigInt('0x8157cd83046453f5dd0972b6e3949e4288020b5b8a9cc99ca07e27089a2ce2436d965026adad3ef7baba37f2183e9b5');\r\n// const ev3 =\r\n//   BigInt('0xab1c2ffdd6c253ca155231eb3e71ba044fd562f6f72bc5bad5ec46a0b7a3b0247cf08ce6c6317f40edbc653a72dee17');\r\n// const ev4 =\r\n//   BigInt('0xaa404866706722864480885d68ad0ccac1967c7544b447873cc37e0181271e006df72162a3d3e0287bf597fbf7f8fc1');\r\n\r\n// Eighth roots of unity, used for computing square roots in Fp2.\r\n// To verify or re-calculate:\r\n// Array(8).fill(new Fp2([1n, 1n])).map((fp2, k) => fp2.pow(Fp2.ORDER * BigInt(k) / 8n))\r\nconst FP2_ROOTS_OF_UNITY = [\r\n  [_1n, _0n],\r\n  [rv1, -rv1],\r\n  [_0n, _1n],\r\n  [rv1, rv1],\r\n  [-_1n, _0n],\r\n  [-rv1, rv1],\r\n  [_0n, -_1n],\r\n  [-rv1, -rv1],\r\n].map((pair) => Fp2.fromBigTuple(pair));\r\n// eta values, used for computing sqrt(g(X1(t)))\r\n// const FP2_ETAs = [\r\n//   [ev1, ev2],\r\n//   [-ev2, ev1],\r\n//   [ev3, ev4],\r\n//   [-ev4, ev3],\r\n// ].map((pair) => Fp2.fromBigTuple(pair));\r\n\r\n// Finite extension field over irreducible polynominal.\r\n// Fp2(v) / (v¬≥ - Œæ) where Œæ = u + 1\r\ntype BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\r\ntype Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\r\nconst Fp6Add = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\r\n  c0: Fp2.add(c0, r0),\r\n  c1: Fp2.add(c1, r1),\r\n  c2: Fp2.add(c2, r2),\r\n});\r\nconst Fp6Subtract = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\r\n  c0: Fp2.sub(c0, r0),\r\n  c1: Fp2.sub(c1, r1),\r\n  c2: Fp2.sub(c2, r2),\r\n});\r\nconst Fp6Multiply = ({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) => {\r\n  if (typeof rhs === 'bigint') {\r\n    return {\r\n      c0: Fp2.mul(c0, rhs),\r\n      c1: Fp2.mul(c1, rhs),\r\n      c2: Fp2.mul(c2, rhs),\r\n    };\r\n  }\r\n  const { c0: r0, c1: r1, c2: r2 } = rhs;\r\n  const t0 = Fp2.mul(c0, r0); // c0 * o0\r\n  const t1 = Fp2.mul(c1, r1); // c1 * o1\r\n  const t2 = Fp2.mul(c2, r2); // c2 * o2\r\n  return {\r\n    // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\r\n    c0: Fp2.add(\r\n      t0,\r\n      Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\r\n    ),\r\n    // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\r\n    c1: Fp2.add(\r\n      Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\r\n      Fp2.mulByNonresidue(t2)\r\n    ),\r\n    // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\r\n    c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\r\n  };\r\n};\r\nconst Fp6Square = ({ c0, c1, c2 }: Fp6) => {\r\n  let t0 = Fp2.sqr(c0); // c0¬≤\r\n  let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\r\n  let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\r\n  let t4 = Fp2.sqr(c2); // c2¬≤\r\n  return {\r\n    c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\r\n    c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\r\n    // T1 + (c0 - c1 + c2)¬≤ + T3 - T0 - T4\r\n    c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\r\n  };\r\n};\r\ntype Fp6Utils = {\r\n  fromBigSix: (tuple: BigintSix) => Fp6;\r\n  mulByNonresidue: (num: Fp6) => Fp6;\r\n  frobeniusMap(num: Fp6, power: number): Fp6;\r\n  multiplyBy1(num: Fp6, b1: Fp2): Fp6;\r\n  multiplyBy01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\r\n  multiplyByFp2(lhs: Fp6, rhs: Fp2): Fp6;\r\n};\r\n\r\nconst Fp6: mod.IField<Fp6> & Fp6Utils = {\r\n  ORDER: Fp2.ORDER, // TODO: unused, but need to verify\r\n  BITS: 3 * Fp2.BITS,\r\n  BYTES: 3 * Fp2.BYTES,\r\n  MASK: bitMask(3 * Fp2.BITS),\r\n  ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\r\n  ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\r\n  create: (num) => num,\r\n  isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\r\n  is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\r\n  neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\r\n  eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) =>\r\n    Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\r\n  sqrt: () => {\r\n    throw new Error('Not implemented');\r\n  },\r\n  // Do we need division by bigint at all? Should be done via order:\r\n  div: (lhs, rhs) => Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\r\n  pow: (num, power) => mod.FpPow(Fp6, num, power),\r\n  invertBatch: (nums) => mod.FpInvertBatch(Fp6, nums),\r\n  // Normalized\r\n  add: Fp6Add,\r\n  sub: Fp6Subtract,\r\n  mul: Fp6Multiply,\r\n  sqr: Fp6Square,\r\n  // NonNormalized stuff\r\n  addN: Fp6Add,\r\n  subN: Fp6Subtract,\r\n  mulN: Fp6Multiply,\r\n  sqrN: Fp6Square,\r\n\r\n  inv: ({ c0, c1, c2 }) => {\r\n    let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0¬≤ - c2 * c1 * (u + 1)\r\n    let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2¬≤ * (u + 1) - c0 * c1\r\n    let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1¬≤ - c0 * c2\r\n    // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\r\n    let t4 = Fp2.inv(\r\n      Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\r\n    );\r\n    return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\r\n  },\r\n  // Bytes utils\r\n  fromBytes: (b: Uint8Array): Fp6 => {\r\n    if (b.length !== Fp6.BYTES) throw new Error(`fromBytes wrong length=${b.length}`);\r\n    return {\r\n      c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\r\n      c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\r\n      c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\r\n    };\r\n  },\r\n  toBytes: ({ c0, c1, c2 }): Uint8Array =>\r\n    concatB(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\r\n  cmov: ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c) => ({\r\n    c0: Fp2.cmov(c0, r0, c),\r\n    c1: Fp2.cmov(c1, r1, c),\r\n    c2: Fp2.cmov(c2, r2, c),\r\n  }),\r\n  // Utils\r\n  //   fromTriple(triple: [Fp2, Fp2, Fp2]) {\r\n  //     return new Fp6(...triple);\r\n  //   }\r\n  //   toString() {\r\n  //     return `Fp6(${this.c0} + ${this.c1} * v, ${this.c2} * v^2)`;\r\n  //   }\r\n  fromBigSix: (t: BigintSix): Fp6 => {\r\n    if (!Array.isArray(t) || t.length !== 6) throw new Error('Invalid Fp6 usage');\r\n    return {\r\n      c0: Fp2.fromBigTuple(t.slice(0, 2)),\r\n      c1: Fp2.fromBigTuple(t.slice(2, 4)),\r\n      c2: Fp2.fromBigTuple(t.slice(4, 6)),\r\n    };\r\n  },\r\n  frobeniusMap: ({ c0, c1, c2 }, power: number) => ({\r\n    c0: Fp2.frobeniusMap(c0, power),\r\n    c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\r\n    c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\r\n  }),\r\n  mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\r\n\r\n  // Sparse multiplication\r\n  multiplyBy1: ({ c0, c1, c2 }, b1: Fp2): Fp6 => ({\r\n    c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\r\n    c1: Fp2.mul(c0, b1),\r\n    c2: Fp2.mul(c1, b1),\r\n  }),\r\n  // Sparse multiplication\r\n  multiplyBy01({ c0, c1, c2 }, b0: Fp2, b1: Fp2): Fp6 {\r\n    let t0 = Fp2.mul(c0, b0); // c0 * b0\r\n    let t1 = Fp2.mul(c1, b1); // c1 * b1\r\n    return {\r\n      // ((c1 + c2) * b1 - T1) * (u + 1) + T0\r\n      c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\r\n      // (b0 + b1) * (c0 + c1) - T0 - T1\r\n      c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\r\n      // (c0 + c2) * b0 - T0 + T1\r\n      c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\r\n    };\r\n  },\r\n\r\n  multiplyByFp2: ({ c0, c1, c2 }, rhs: Fp2): Fp6 => ({\r\n    c0: Fp2.mul(c0, rhs),\r\n    c1: Fp2.mul(c1, rhs),\r\n    c2: Fp2.mul(c2, rhs),\r\n  }),\r\n};\r\n\r\nconst FP6_FROBENIUS_COEFFICIENTS_1 = [\r\n  [BigInt('0x1'), BigInt('0x0')],\r\n  [\r\n    BigInt('0x0'),\r\n    BigInt(\r\n      '0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'\r\n    ),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [BigInt('0x0'), BigInt('0x1')],\r\n  [\r\n    BigInt(\r\n      '0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt('0x0'),\r\n    BigInt(\r\n      '0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\r\n    ),\r\n  ],\r\n].map((pair) => Fp2.fromBigTuple(pair));\r\nconst FP6_FROBENIUS_COEFFICIENTS_2 = [\r\n  [BigInt('0x1'), BigInt('0x0')],\r\n  [\r\n    BigInt(\r\n      '0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n].map((pair) => Fp2.fromBigTuple(pair));\r\n\r\n// Finite extension field over irreducible polynominal.\r\n// Fp‚ÇÅ‚ÇÇ = Fp‚ÇÜ¬≤ => Fp‚ÇÇ¬≥\r\n// Fp‚ÇÜ(w) / (w¬≤ - Œ≥) where Œ≥ = v\r\ntype Fp12 = { c0: Fp6; c1: Fp6 };\r\n// The BLS parameter x for BLS12-381\r\nconst BLS_X = BigInt('0xd201000000010000');\r\nconst BLS_X_LEN = bitLen(BLS_X);\r\n\r\n// prettier-ignore\r\ntype BigintTwelve = [\r\n    bigint, bigint, bigint, bigint, bigint, bigint,\r\n    bigint, bigint, bigint, bigint, bigint, bigint\r\n  ];\r\nconst Fp12Add = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\r\n  c0: Fp6.add(c0, r0),\r\n  c1: Fp6.add(c1, r1),\r\n});\r\nconst Fp12Subtract = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\r\n  c0: Fp6.sub(c0, r0),\r\n  c1: Fp6.sub(c1, r1),\r\n});\r\nconst Fp12Multiply = ({ c0, c1 }: Fp12, rhs: Fp12 | bigint) => {\r\n  if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\r\n  let { c0: r0, c1: r1 } = rhs;\r\n  let t1 = Fp6.mul(c0, r0); // c0 * r0\r\n  let t2 = Fp6.mul(c1, r1); // c1 * r1\r\n  return {\r\n    c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\r\n    // (c0 + c1) * (r0 + r1) - (T1 + T2)\r\n    c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\r\n  };\r\n};\r\nconst Fp12Square = ({ c0, c1 }: Fp12) => {\r\n  let ab = Fp6.mul(c0, c1); // c0 * c1\r\n  return {\r\n    // (c1 * v + c0) * (c0 + c1) - AB - AB * v\r\n    c0: Fp6.sub(\r\n      Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\r\n      Fp6.mulByNonresidue(ab)\r\n    ),\r\n    c1: Fp6.add(ab, ab),\r\n  }; // AB + AB\r\n};\r\nfunction Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\r\n  const a2 = Fp2.sqr(a);\r\n  const b2 = Fp2.sqr(b);\r\n  return {\r\n    first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b¬≤ * Nonresidue + a¬≤\r\n    second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)¬≤ - a¬≤ - b¬≤\r\n  };\r\n}\r\ntype Fp12Utils = {\r\n  fromBigTwelve: (t: BigintTwelve) => Fp12;\r\n  frobeniusMap(num: Fp12, power: number): Fp12;\r\n  multiplyBy014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\r\n  multiplyByFp2(lhs: Fp12, rhs: Fp2): Fp12;\r\n  conjugate(num: Fp12): Fp12;\r\n  finalExponentiate(num: Fp12): Fp12;\r\n  _cyclotomicSquare(num: Fp12): Fp12;\r\n  _cyclotomicExp(num: Fp12, n: bigint): Fp12;\r\n};\r\n\r\nconst Fp12: mod.IField<Fp12> & Fp12Utils = {\r\n  ORDER: Fp2.ORDER, // TODO: unused, but need to verify\r\n  BITS: 2 * Fp2.BITS,\r\n  BYTES: 2 * Fp2.BYTES,\r\n  MASK: bitMask(2 * Fp2.BITS),\r\n  ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\r\n  ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\r\n  create: (num) => num,\r\n  isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\r\n  is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\r\n  neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\r\n  eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\r\n  sqrt: () => {\r\n    throw new Error('Not implemented');\r\n  },\r\n  inv: ({ c0, c1 }) => {\r\n    let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0¬≤ - c1¬≤ * v)\r\n    return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\r\n  },\r\n  div: (lhs, rhs) =>\r\n    Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\r\n  pow: (num, power) => mod.FpPow(Fp12, num, power),\r\n  invertBatch: (nums) => mod.FpInvertBatch(Fp12, nums),\r\n  // Normalized\r\n  add: Fp12Add,\r\n  sub: Fp12Subtract,\r\n  mul: Fp12Multiply,\r\n  sqr: Fp12Square,\r\n  // NonNormalized stuff\r\n  addN: Fp12Add,\r\n  subN: Fp12Subtract,\r\n  mulN: Fp12Multiply,\r\n  sqrN: Fp12Square,\r\n\r\n  // Bytes utils\r\n  fromBytes: (b: Uint8Array): Fp12 => {\r\n    if (b.length !== Fp12.BYTES) throw new Error(`fromBytes wrong length=${b.length}`);\r\n    return {\r\n      c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\r\n      c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\r\n    };\r\n  },\r\n  toBytes: ({ c0, c1 }): Uint8Array => concatB(Fp6.toBytes(c0), Fp6.toBytes(c1)),\r\n  cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\r\n    c0: Fp6.cmov(c0, r0, c),\r\n    c1: Fp6.cmov(c1, r1, c),\r\n  }),\r\n  // Utils\r\n  // toString() {\r\n  //   return `Fp12(${this.c0} + ${this.c1} * w)`;\r\n  // },\r\n  // fromTuple(c: [Fp6, Fp6]) {\r\n  //   return new Fp12(...c);\r\n  // }\r\n  fromBigTwelve: (t: BigintTwelve): Fp12 => ({\r\n    c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\r\n    c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\r\n  }),\r\n  // Raises to q**i -th power\r\n  frobeniusMap(lhs, power: number) {\r\n    const r0 = Fp6.frobeniusMap(lhs.c0, power);\r\n    const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\r\n    const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\r\n    return {\r\n      c0: r0,\r\n      c1: Fp6.create({\r\n        c0: Fp2.mul(c0, coeff),\r\n        c1: Fp2.mul(c1, coeff),\r\n        c2: Fp2.mul(c2, coeff),\r\n      }),\r\n    };\r\n  },\r\n  // Sparse multiplication\r\n  multiplyBy014: ({ c0, c1 }, o0: Fp2, o1: Fp2, o4: Fp2) => {\r\n    let t0 = Fp6.multiplyBy01(c0, o0, o1);\r\n    let t1 = Fp6.multiplyBy1(c1, o4);\r\n    return {\r\n      c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\r\n      // (c1 + c0) * [o0, o1+o4] - T0 - T1\r\n      c1: Fp6.sub(Fp6.sub(Fp6.multiplyBy01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\r\n    };\r\n  },\r\n  multiplyByFp2: ({ c0, c1 }, rhs: Fp2): Fp12 => ({\r\n    c0: Fp6.multiplyByFp2(c0, rhs),\r\n    c1: Fp6.multiplyByFp2(c1, rhs),\r\n  }),\r\n  conjugate: ({ c0, c1 }): Fp12 => ({ c0, c1: Fp6.neg(c1) }),\r\n\r\n  // A cyclotomic group is a subgroup of Fp^n defined by\r\n  //   GŒ¶‚Çô(p) = {Œ± ‚àà Fp‚Åø : Œ±^Œ¶‚Çô(p) = 1}\r\n  // The result of any pairing is in a cyclotomic subgroup\r\n  // https://eprint.iacr.org/2009/565.pdf\r\n  _cyclotomicSquare: ({ c0, c1 }): Fp12 => {\r\n    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\r\n    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\r\n    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\r\n    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\r\n    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\r\n    let t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\r\n    return {\r\n      c0: Fp6.create({\r\n        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\r\n        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\r\n        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\r\n      }), // 2 * (T7 - c0c2)  + T7\r\n      c1: Fp6.create({\r\n        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\r\n        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\r\n        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\r\n      }),\r\n    }; // 2 * (T6 + c1c2) + T6\r\n  },\r\n  _cyclotomicExp(num, n) {\r\n    let z = Fp12.ONE;\r\n    for (let i = BLS_X_LEN - 1; i >= 0; i--) {\r\n      z = Fp12._cyclotomicSquare(z);\r\n      if (bitGet(n, i)) z = Fp12.mul(z, num);\r\n    }\r\n    return z;\r\n  },\r\n  // https://eprint.iacr.org/2010/354.pdf\r\n  // https://eprint.iacr.org/2009/565.pdf\r\n  finalExponentiate: (num) => {\r\n    const x = BLS_X;\r\n    // this^(q‚Å∂) / this\r\n    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\r\n    // t0^(q¬≤) * t0\r\n    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\r\n    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\r\n    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\r\n    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\r\n    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\r\n    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\r\n    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\r\n    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\r\n    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\r\n    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\r\n    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\r\n    // (t2 * t5)^(q¬≤) * (t4 * t1)^(q¬≥) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\r\n    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\r\n  },\r\n};\r\nconst FP12_FROBENIUS_COEFFICIENTS = [\r\n  [BigInt('0x1'), BigInt('0x0')],\r\n  [\r\n    BigInt(\r\n      '0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'\r\n    ),\r\n    BigInt(\r\n      '0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'\r\n    ),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'\r\n    ),\r\n    BigInt(\r\n      '0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'\r\n    ),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'\r\n    ),\r\n    BigInt(\r\n      '0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'\r\n    ),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'\r\n    ),\r\n    BigInt(\r\n      '0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'\r\n    ),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'\r\n    ),\r\n    BigInt(\r\n      '0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'\r\n    ),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'\r\n    ),\r\n    BigInt('0x0'),\r\n  ],\r\n  [\r\n    BigInt(\r\n      '0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'\r\n    ),\r\n    BigInt(\r\n      '0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'\r\n    ),\r\n  ],\r\n].map((n) => Fp2.fromBigTuple(n));\r\n// END OF CURVE FIELDS\r\n\r\n// HashToCurve\r\n\r\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\r\nconst isogenyMapG2 = isogenyMap(\r\n  Fp2,\r\n  [\r\n    // xNum\r\n    [\r\n      [\r\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\r\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\r\n      ],\r\n      [\r\n        '0x0',\r\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\r\n      ],\r\n      [\r\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\r\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\r\n      ],\r\n      [\r\n        '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\r\n        '0x0',\r\n      ],\r\n    ],\r\n    // xDen\r\n    [\r\n      [\r\n        '0x0',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\r\n      ],\r\n      [\r\n        '0xc',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\r\n      ],\r\n      ['0x1', '0x0'], // LAST 1\r\n    ],\r\n    // yNum\r\n    [\r\n      [\r\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\r\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\r\n      ],\r\n      [\r\n        '0x0',\r\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\r\n      ],\r\n      [\r\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\r\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\r\n      ],\r\n      [\r\n        '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\r\n        '0x0',\r\n      ],\r\n    ],\r\n    // yDen\r\n    [\r\n      [\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\r\n      ],\r\n      [\r\n        '0x0',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\r\n      ],\r\n      [\r\n        '0x12',\r\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\r\n      ],\r\n      ['0x1', '0x0'], // LAST 1\r\n    ],\r\n  ].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))) as [Fp2[], Fp2[], Fp2[], Fp2[]]\r\n);\r\n// 11-isogeny map from E' to E\r\nconst isogenyMapG1 = isogenyMap(\r\n  Fp,\r\n  [\r\n    // xNum\r\n    [\r\n      '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\r\n      '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\r\n      '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\r\n      '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\r\n      '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\r\n      '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\r\n      '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\r\n      '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\r\n      '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\r\n      '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\r\n      '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\r\n      '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\r\n    ],\r\n    // xDen\r\n    [\r\n      '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\r\n      '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\r\n      '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\r\n      '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\r\n      '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\r\n      '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\r\n      '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\r\n      '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\r\n      '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\r\n      '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\r\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n    ],\r\n    // yNum\r\n    [\r\n      '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\r\n      '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\r\n      '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\r\n      '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\r\n      '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\r\n      '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\r\n      '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\r\n      '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\r\n      '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\r\n      '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\r\n      '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\r\n      '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\r\n      '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\r\n      '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\r\n      '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\r\n      '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\r\n    ],\r\n    // yDen\r\n    [\r\n      '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\r\n      '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\r\n      '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\r\n      '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\r\n      '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\r\n      '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\r\n      '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\r\n      '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\r\n      '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\r\n      '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\r\n      '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\r\n      '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\r\n      '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\r\n      '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\r\n      '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\r\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\r\n    ],\r\n  ].map((i) => i.map((j) => BigInt(j))) as [Fp[], Fp[], Fp[], Fp[]]\r\n);\r\n\r\n// SWU Map - Fp2 to G2': y¬≤ = x¬≥ + 240i * x + 1012 + 1012i\r\nconst G2_SWU = mapToCurveSimpleSWU(Fp2, {\r\n  A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\r\n  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\r\n  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\r\n});\r\n// Optimized SWU Map - Fp to G1\r\nconst G1_SWU = mapToCurveSimpleSWU(Fp, {\r\n  A: Fp.create(\r\n    BigInt(\r\n      '0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d'\r\n    )\r\n  ),\r\n  B: Fp.create(\r\n    BigInt(\r\n      '0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0'\r\n    )\r\n  ),\r\n  Z: Fp.create(BigInt(11)),\r\n});\r\n\r\n// Endomorphisms (for fast cofactor clearing)\r\n// Œ®(P) endomorphism\r\nconst ut_root = Fp6.create({ c0: Fp2.ZERO, c1: Fp2.ONE, c2: Fp2.ZERO });\r\nconst wsq = Fp12.create({ c0: ut_root, c1: Fp6.ZERO });\r\nconst wcu = Fp12.create({ c0: Fp6.ZERO, c1: ut_root });\r\nconst [wsq_inv, wcu_inv] = Fp12.invertBatch([wsq, wcu]);\r\nfunction psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\r\n  // Untwist Fp2->Fp12 && frobenius(1) && twist back\r\n  const x2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wsq_inv, x), 1), wsq).c0.c0;\r\n  const y2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wcu_inv, y), 1), wcu).c0.c0;\r\n  return [x2, y2];\r\n}\r\n// Œ® endomorphism\r\nfunction G2psi(c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) {\r\n  const affine = P.toAffine();\r\n  const p = psi(affine.x, affine.y);\r\n  return new c(p[0], p[1], Fp2.ONE);\r\n}\r\n// Œ®¬≤(P) endomorphism\r\n// 1 / F2(2)^((p-1)/3) in GF(p¬≤)\r\nconst PSI2_C1 = BigInt(\r\n  '0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'\r\n);\r\n\r\nfunction psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\r\n  return [Fp2.mul(x, PSI2_C1), Fp2.neg(y)];\r\n}\r\nfunction G2psi2(c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) {\r\n  const affine = P.toAffine();\r\n  const p = psi2(affine.x, affine.y);\r\n  return new c(p[0], p[1], Fp2.ONE);\r\n}\r\n\r\n// Default hash_to_field options are for hash to G2.\r\n//\r\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\r\n// Parameter values come from section 8.8.2 of the spec.\r\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\r\n//\r\n// Base field F is GF(p^m)\r\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\r\n// m = 2 (or 1 for G1 see section 8.8.1)\r\n// k = 128\r\nconst htfDefaults = Object.freeze({\r\n  // DST: a domain separation tag\r\n  // defined in section 2.2.5\r\n  // Use utils.getDSTLabel(), utils.setDSTLabel(value)\r\n  DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\r\n  encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\r\n  // p: the characteristic of F\r\n  //    where F is a finite field of characteristic p and order q = p^m\r\n  p: Fp.ORDER,\r\n  // m: the extension degree of F, m >= 1\r\n  //     where F is a finite field of characteristic p and order q = p^m\r\n  m: 2,\r\n  // k: the target security level for the suite in bits\r\n  // defined in section 5.1\r\n  k: 128,\r\n  // option to use a message that has already been processed by\r\n  // expand_message_xmd\r\n  expand: 'xmd',\r\n  // Hash functions for: expand_message_xmd is appropriate for use with a\r\n  // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\r\n  // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\r\n  hash: sha256,\r\n} as const);\r\n\r\n// Encoding utils\r\n// Point on G1 curve: (x, y)\r\n\r\n// Compressed point of infinity\r\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\r\n\r\nfunction parseMask(bytes: Uint8Array) {\r\n  // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\r\n  bytes = bytes.slice();\r\n  const mask = bytes[0] & 0b1110_0000;\r\n  const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\r\n  const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\r\n  const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\r\n  bytes[0] &= 0b0001_1111; // clear mask (zero first 3 bits)\r\n  return { compressed, infinity, sort, value: bytes };\r\n}\r\n\r\nfunction setMask(\r\n  bytes: Uint8Array,\r\n  mask: { compressed?: boolean; infinity?: boolean; sort?: boolean }\r\n) {\r\n  if (bytes[0] & 0b1110_0000) throw new Error('setMask: non-empty mask');\r\n  if (mask.compressed) bytes[0] |= 0b1000_0000;\r\n  if (mask.infinity) bytes[0] |= 0b0100_0000;\r\n  if (mask.sort) bytes[0] |= 0b0010_0000;\r\n  return bytes;\r\n}\r\n\r\nfunction signatureG1ToRawBytes(point: ProjPointType<Fp>) {\r\n  point.assertValidity();\r\n  const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\r\n  const { x, y } = point.toAffine();\r\n  if (isZero) return COMPRESSED_ZERO.slice();\r\n  const P = Fp.ORDER;\r\n  const sort = Boolean((y * _2n) / P);\r\n  return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\r\n}\r\n\r\nfunction signatureG2ToRawBytes(point: ProjPointType<Fp2>) {\r\n  // NOTE: by some reasons it was missed in bls12-381, looks like bug\r\n  point.assertValidity();\r\n  const len = Fp.BYTES;\r\n  if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\r\n    return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\r\n  const { x, y } = point.toAffine();\r\n  const { re: x0, im: x1 } = Fp2.reim(x);\r\n  const { re: y0, im: y1 } = Fp2.reim(y);\r\n  const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\r\n  const sort = Boolean((tmp / Fp.ORDER) & _1n);\r\n  const z2 = x0;\r\n  return concatB(\r\n    setMask(numberToBytesBE(x1, len), { sort, compressed: true }),\r\n    numberToBytesBE(z2, len)\r\n  );\r\n}\r\n\r\n// To verify curve parameters, see pairing-friendly-curves spec:\r\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11\r\n// Basic math is done over finite fields over p.\r\n// More complicated math is done over polynominal extension fields.\r\n// To simplify calculations in Fp12, we construct extension tower:\r\n// Fp‚ÇÅ‚ÇÇ = Fp‚ÇÜ¬≤ => Fp‚ÇÇ¬≥\r\n// Fp(u) / (u¬≤ - Œ≤) where Œ≤ = -1\r\n// Fp‚ÇÇ(v) / (v¬≥ - Œæ) where Œæ = u + 1\r\n// Fp‚ÇÜ(w) / (w¬≤ - Œ≥) where Œ≥ = v\r\n// Here goes constants && point encoding format\r\nexport const bls12_381: CurveFn<Fp, Fp2, Fp6, Fp12> = bls({\r\n  // Fields\r\n  fields: {\r\n    Fp,\r\n    Fp2,\r\n    Fp6,\r\n    Fp12,\r\n    Fr,\r\n  },\r\n  // G1 is the order-q subgroup of E1(Fp) : y¬≤ = x¬≥ + 4, #E1(Fp) = h1q, where\r\n  // characteristic; z + (z‚Å¥ - z¬≤ + 1)(z - 1)¬≤/3\r\n  G1: {\r\n    Fp,\r\n    // cofactor; (z - 1)¬≤/3\r\n    h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\r\n    // generator's coordinates\r\n    // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\r\n    // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\r\n    Gx: BigInt(\r\n      '0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'\r\n    ),\r\n    Gy: BigInt(\r\n      '0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'\r\n    ),\r\n    a: Fp.ZERO,\r\n    b: _4n,\r\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\r\n    wrapPrivateKey: true,\r\n    allowInfinityPoint: true,\r\n    // Checks is the point resides in prime-order subgroup.\r\n    // point.isTorsionFree() should return true for valid points\r\n    // It returns false for shitty points.\r\n    // https://eprint.iacr.org/2021/1130.pdf\r\n    isTorsionFree: (c, point): boolean => {\r\n      // œÜ endomorphism\r\n      const cubicRootOfUnityModP = BigInt(\r\n        '0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\r\n      );\r\n      const phi = new c(Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);\r\n\r\n      // todo: unroll\r\n      const xP = point.multiplyUnsafe(bls12_381.params.x).negate(); // [x]P\r\n      const u2P = xP.multiplyUnsafe(bls12_381.params.x); // [u2]P\r\n      return u2P.equals(phi);\r\n\r\n      // https://eprint.iacr.org/2019/814.pdf\r\n      // (z¬≤ ‚àí 1)/3\r\n      // const c1 = BigInt('0x396c8c005555e1560000000055555555');\r\n      // const P = this;\r\n      // const S = P.sigma();\r\n      // const Q = S.double();\r\n      // const S2 = S.sigma();\r\n      // // [(z¬≤ ‚àí 1)/3](2œÉ(P) ‚àí P ‚àí œÉ¬≤(P)) ‚àí œÉ¬≤(P) = O\r\n      // const left = Q.subtract(P).subtract(S2).multiplyUnsafe(c1);\r\n      // const C = left.subtract(S2);\r\n      // return C.isZero();\r\n    },\r\n    // Clear cofactor of G1\r\n    // https://eprint.iacr.org/2019/403\r\n    clearCofactor: (_c, point) => {\r\n      // return this.multiplyUnsafe(CURVE.h);\r\n      return point.multiplyUnsafe(bls12_381.params.x).add(point); // x*P + P\r\n    },\r\n    mapToCurve: (scalars: bigint[]) => {\r\n      const { x, y } = G1_SWU(Fp.create(scalars[0]));\r\n      return isogenyMapG1(x, y);\r\n    },\r\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp> => {\r\n      const { compressed, infinity, sort, value } = parseMask(bytes);\r\n      if (value.length === 48 && compressed) {\r\n        // TODO: Fp.bytes\r\n        const P = Fp.ORDER;\r\n        const compressedValue = bytesToNumberBE(value);\r\n        // Zero\r\n        const x = Fp.create(compressedValue & Fp.MASK);\r\n        if (infinity) {\r\n          if (x !== _0n) throw new Error('G1: non-empty compressed point at infinity');\r\n          return { x: _0n, y: _0n };\r\n        }\r\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y¬≤ = x¬≥ + b\r\n        let y = Fp.sqrt(right);\r\n        if (!y) throw new Error('Invalid compressed G1 point');\r\n        if ((y * _2n) / P !== BigInt(sort)) y = Fp.neg(y);\r\n        return { x: Fp.create(x), y: Fp.create(y) };\r\n      } else if (value.length === 96 && !compressed) {\r\n        // Check if the infinity flag is set\r\n        const x = bytesToNumberBE(value.subarray(0, Fp.BYTES));\r\n        const y = bytesToNumberBE(value.subarray(Fp.BYTES));\r\n        if (infinity) {\r\n          if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');\r\n          return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\r\n        }\r\n        return { x: Fp.create(x), y: Fp.create(y) };\r\n      } else {\r\n        throw new Error('Invalid point G1, expected 48/96 bytes');\r\n      }\r\n    },\r\n    toBytes: (c, point, isCompressed) => {\r\n      const isZero = point.equals(c.ZERO);\r\n      const { x, y } = point.toAffine();\r\n      if (isCompressed) {\r\n        if (isZero) return COMPRESSED_ZERO.slice();\r\n        const P = Fp.ORDER;\r\n        const sort = Boolean((y * _2n) / P);\r\n        return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\r\n      } else {\r\n        if (isZero) {\r\n          // 2x PUBLIC_KEY_LENGTH\r\n          const x = concatB(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\r\n          return x;\r\n        } else {\r\n          return concatB(numberToBytesBE(x, Fp.BYTES), numberToBytesBE(y, Fp.BYTES));\r\n        }\r\n      }\r\n    },\r\n    ShortSignature: {\r\n      fromHex(hex: Hex): ProjPointType<Fp> {\r\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex, 48));\r\n        const P = Fp.ORDER;\r\n        const compressedValue = bytesToNumberBE(value);\r\n        // Zero\r\n        if (infinity) return bls12_381.G1.ProjectivePoint.ZERO;\r\n        const x = Fp.create(compressedValue & Fp.MASK);\r\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y¬≤ = x¬≥ + b\r\n        let y = Fp.sqrt(right);\r\n        if (!y) throw new Error('Invalid compressed G1 point');\r\n        const aflag = BigInt(sort);\r\n        if ((y * _2n) / P !== aflag) y = Fp.neg(y);\r\n        const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\r\n        point.assertValidity();\r\n        return point;\r\n      },\r\n      toRawBytes(point: ProjPointType<Fp>) {\r\n        return signatureG1ToRawBytes(point);\r\n      },\r\n      toHex(point: ProjPointType<Fp>) {\r\n        return bytesToHex(signatureG1ToRawBytes(point));\r\n      },\r\n    },\r\n  },\r\n  // G2 is the order-q subgroup of E2(Fp¬≤) : y¬≤ = x¬≥+4(1+‚àö‚àí1),\r\n  // where Fp2 is Fp[‚àö‚àí1]/(x2+1). #E2(Fp2 ) = h2q, where\r\n  // G¬≤ - 1\r\n  // h2q\r\n  G2: {\r\n    Fp: Fp2,\r\n    // cofactor\r\n    h: BigInt(\r\n      '0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'\r\n    ),\r\n    Gx: Fp2.fromBigTuple([\r\n      BigInt(\r\n        '0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'\r\n      ),\r\n      BigInt(\r\n        '0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'\r\n      ),\r\n    ]),\r\n    // y =\r\n    // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\r\n    // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\r\n    Gy: Fp2.fromBigTuple([\r\n      BigInt(\r\n        '0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'\r\n      ),\r\n      BigInt(\r\n        '0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'\r\n      ),\r\n    ]),\r\n    a: Fp2.ZERO,\r\n    b: Fp2.fromBigTuple([_4n, _4n]),\r\n    hEff: BigInt(\r\n      '0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'\r\n    ),\r\n    htfDefaults: { ...htfDefaults },\r\n    wrapPrivateKey: true,\r\n    allowInfinityPoint: true,\r\n    mapToCurve: (scalars: bigint[]) => {\r\n      const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\r\n      return isogenyMapG2(x, y);\r\n    },\r\n    // Checks is the point resides in prime-order subgroup.\r\n    // point.isTorsionFree() should return true for valid points\r\n    // It returns false for shitty points.\r\n    // https://eprint.iacr.org/2021/1130.pdf\r\n    isTorsionFree: (c, P): boolean => {\r\n      return P.multiplyUnsafe(bls12_381.params.x).negate().equals(G2psi(c, P)); // œà(P) == [u](P)\r\n      // Older version: https://eprint.iacr.org/2019/814.pdf\r\n      // Œ®¬≤(P) => Œ®¬≥(P) => [z]Œ®¬≥(P) where z = -x => [z]Œ®¬≥(P) - Œ®¬≤(P) + P == O\r\n      // return P.psi2().psi().mulNegX().subtract(psi2).add(P).isZero();\r\n    },\r\n    // Maps the point into the prime-order subgroup G2.\r\n    // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11\r\n    // https://eprint.iacr.org/2017/419.pdf\r\n    // prettier-ignore\r\n    clearCofactor: (c, P) => {\r\n      const x = bls12_381.params.x;\r\n      let t1 = P.multiplyUnsafe(x).negate();  // [-x]P\r\n      let t2 = G2psi(c, P);                   // Œ®(P)\r\n      let t3 = P.double();                    // 2P\r\n      t3 = G2psi2(c, t3);                     // Œ®¬≤(2P)\r\n      t3 = t3.subtract(t2);                   // Œ®¬≤(2P) - Œ®(P)\r\n      t2 = t1.add(t2);                        // [-x]P + Œ®(P)\r\n      t2 = t2.multiplyUnsafe(x).negate();     // [x¬≤]P - [x]Œ®(P)\r\n      t3 = t3.add(t2);                        // Œ®¬≤(2P) - Œ®(P) + [x¬≤]P - [x]Œ®(P)\r\n      t3 = t3.subtract(t1);                   // Œ®¬≤(2P) - Œ®(P) + [x¬≤]P - [x]Œ®(P) + [x]P\r\n      const Q = t3.subtract(P);               // Œ®¬≤(2P) - Œ®(P) + [x¬≤]P - [x]Œ®(P) + [x]P - 1P\r\n      return Q;                               // [x¬≤-x-1]P + [x-1]Œ®(P) + Œ®¬≤(2P)\r\n    },\r\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp2> => {\r\n      const { compressed, infinity, sort, value } = parseMask(bytes);\r\n      if (\r\n        (!compressed && !infinity && sort) || // 00100000\r\n        (!compressed && infinity && sort) || // 01100000\r\n        (sort && infinity && compressed) // 11100000\r\n      ) {\r\n        throw new Error('Invalid encoding flag: ' + (bytes[0] & 0b1110_0000));\r\n      }\r\n      const L = Fp.BYTES;\r\n      const slc = (b: Uint8Array, from: number, to?: number) => bytesToNumberBE(b.slice(from, to));\r\n      if (value.length === 96 && compressed) {\r\n        const b = bls12_381.params.G2b;\r\n        const P = Fp.ORDER;\r\n        if (infinity) {\r\n          // check that all bytes are 0\r\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\r\n            throw new Error('Invalid compressed G2 point');\r\n          }\r\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\r\n        }\r\n        const x_1 = slc(value, 0, L);\r\n        const x_0 = slc(value, L, 2 * L);\r\n        const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\r\n        const right = Fp2.add(Fp2.pow(x, _3n), b); // y¬≤ = x¬≥ + 4 * (u+1) = x¬≥ + b\r\n        let y = Fp2.sqrt(right);\r\n        const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\r\n        y = sort && Y_bit > 0 ? y : Fp2.neg(y);\r\n        return { x, y };\r\n      } else if (value.length === 192 && !compressed) {\r\n        if (infinity) {\r\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\r\n            throw new Error('Invalid uncompressed G2 point');\r\n          }\r\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\r\n        }\r\n        const x1 = slc(value, 0, L);\r\n        const x0 = slc(value, L, 2 * L);\r\n        const y1 = slc(value, 2 * L, 3 * L);\r\n        const y0 = slc(value, 3 * L, 4 * L);\r\n        return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\r\n      } else {\r\n        throw new Error('Invalid point G2, expected 96/192 bytes');\r\n      }\r\n    },\r\n    toBytes: (c, point, isCompressed) => {\r\n      const { BYTES: len, ORDER: P } = Fp;\r\n      const isZero = point.equals(c.ZERO);\r\n      const { x, y } = point.toAffine();\r\n      if (isCompressed) {\r\n        if (isZero) return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\r\n        const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\r\n        return concatB(\r\n          setMask(numberToBytesBE(x.c1, len), { compressed: true, sort: flag }),\r\n          numberToBytesBE(x.c0, len)\r\n        );\r\n      } else {\r\n        if (isZero) return concatB(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\r\n        const { re: x0, im: x1 } = Fp2.reim(x);\r\n        const { re: y0, im: y1 } = Fp2.reim(y);\r\n        return concatB(\r\n          numberToBytesBE(x1, len),\r\n          numberToBytesBE(x0, len),\r\n          numberToBytesBE(y1, len),\r\n          numberToBytesBE(y0, len)\r\n        );\r\n      }\r\n    },\r\n    Signature: {\r\n      // TODO: Optimize, it's very slow because of sqrt.\r\n      fromHex(hex: Hex): ProjPointType<Fp2> {\r\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex));\r\n        const P = Fp.ORDER;\r\n        const half = hex.length / 2;\r\n        if (half !== 48 && half !== 96)\r\n          throw new Error('Invalid compressed signature length, must be 96 or 192');\r\n        const z1 = bytesToNumberBE(value.slice(0, half));\r\n        const z2 = bytesToNumberBE(value.slice(half));\r\n        // Indicates the infinity point\r\n        if (infinity) return bls12_381.G2.ProjectivePoint.ZERO;\r\n        const x1 = Fp.create(z1 & Fp.MASK);\r\n        const x2 = Fp.create(z2);\r\n        const x = Fp2.create({ c0: x2, c1: x1 });\r\n        const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y¬≤ = x¬≥ + 4\r\n        // The slow part\r\n        let y = Fp2.sqrt(y2);\r\n        if (!y) throw new Error('Failed to find a square root');\r\n\r\n        // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\r\n        // If y1 happens to be zero, then use the bit of y0\r\n        const { re: y0, im: y1 } = Fp2.reim(y);\r\n        const aflag1 = BigInt(sort);\r\n        const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\r\n        const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\r\n        if (isGreater || isZero) y = Fp2.neg(y);\r\n        const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\r\n        point.assertValidity();\r\n        return point;\r\n      },\r\n      toRawBytes(point: ProjPointType<Fp2>) {\r\n        return signatureG2ToRawBytes(point);\r\n      },\r\n      toHex(point: ProjPointType<Fp2>) {\r\n        return bytesToHex(signatureG2ToRawBytes(point));\r\n      },\r\n    },\r\n  },\r\n  params: {\r\n    x: BLS_X, // The BLS parameter x for BLS12-381\r\n    r: Fr.ORDER, // order; z‚Å¥ ‚àí z¬≤ + 1; CURVE.n from other curves\r\n  },\r\n  htfDefaults,\r\n  hash: sha256,\r\n  randomBytes,\r\n});\r\n"],
  "mappings": "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",
  "names": ["Fp", "bitLen", "_0n", "_1n", "Fp", "_0n", "_1n", "_2n", "_3n", "_4n", "Fp", "a", "Fp", "_0n", "_1n", "_2n", "tv5", "_4n", "_3n", "c1", "c2", "_2n", "_3n", "Fp", "Fr", "Fp2", "Fp6", "Fp12", "BLS_X_LEN", "t0", "t1", "t2", "t3", "t4", "groupPublicKey", "_0n", "_1n", "_2n", "_3n", "_4n", "_8n", "_16n", "x"]
}
